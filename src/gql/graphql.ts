/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** represents a date of the following format: YYYY-MM-DD */
  Date: any;
  /** represents a timestamp of the ISO8601 format */
  DateTime: any;
};

/** Autogenerated input type of AcceptContract */
export type AcceptContractInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  contractRawId?: InputMaybe<Scalars['Int']>;
  freelancerAgreesTerms?: InputMaybe<Scalars['Boolean']>;
  freelancerContactEmail?: InputMaybe<Scalars['String']>;
  freelancerFeedback?: InputMaybe<Scalars['String']>;
  freelancerMessage?: InputMaybe<Scalars['String']>;
  interviewDate?: InputMaybe<Scalars['DateTime']>;
  /** @deprecated use updateUser to update the phone number */
  phone?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AcceptContract. */
export type AcceptContractPayload = {
  __typename?: 'AcceptContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of AcceptContractRequests */
export type AcceptContractRequestsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  contractRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of AcceptContractRequests. */
export type AcceptContractRequestsPayload = {
  __typename?: 'AcceptContractRequestsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

export type Answer = Node & {
  __typename?: 'Answer';
  contractRequests?: Maybe<Array<ContractRequest>>;
  id: Scalars['ID'];
  question?: Maybe<Question>;
  questionId: Scalars['Int'];
  /** @deprecated used only by some legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  textualAnswer?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  user?: Maybe<User>;
  userId: Scalars['Int'];
  video?: Maybe<Video>;
};

/** API keys used to access Flexhire programmatically */
export type ApiKey = Node & {
  __typename?: 'ApiKey';
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** slice of the actual key, to be used to identify it */
  keySlice?: Maybe<Scalars['String']>;
  lastUsedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};

export type ApiKeyTestResult = {
  __typename?: 'ApiKeyTestResult';
  error?: Maybe<Scalars['String']>;
  valid: Scalars['Boolean'];
};

export type ApplicationsResults = {
  __typename?: 'ApplicationsResults';
  applications?: Maybe<ContractConnection>;
  filteredOutCount: Scalars['Int'];
  filteredOutIds: Array<Scalars['Int']>;
  highlightCount: Scalars['Int'];
  highlightCountMyTeam: Scalars['Int'];
  totalCount: Scalars['Int'];
  totalCountMyTeam: Scalars['Int'];
};


export type ApplicationsResultsApplicationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of ApplyToJob */
export type ApplyToJobInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  jobId?: InputMaybe<Scalars['ID']>;
  /** @deprecated use jobId instead */
  jobSlug?: InputMaybe<Scalars['String']>;
  /** used to track which external platform or context the user came from */
  ref?: InputMaybe<Scalars['String']>;
  /** the page from which the user was referred before applying to the job */
  refererUrl?: InputMaybe<Scalars['String']>;
  /** set to what status the job application should be recorded at */
  status?: InputMaybe<ContractStatus>;
};

/** Autogenerated return type of ApplyToJob. */
export type ApplyToJobPayload = {
  __typename?: 'ApplyToJobPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

export enum ApprovalTypeEnum {
  AutoApproval = 'auto_approval',
  ManualApproval = 'manual_approval'
}

/** Autogenerated input type of ApprovePayrollItem */
export type ApprovePayrollItemInput = {
  bonusId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRatingFeedbackContinue?: InputMaybe<Scalars['String']>;
  clientRatingFeedbackStart?: InputMaybe<Scalars['String']>;
  clientRatingFeedbackStop?: InputMaybe<Scalars['String']>;
  clientRatingScore?: InputMaybe<Scalars['Int']>;
  expenseId?: InputMaybe<Scalars['ID']>;
  payrollItemId?: InputMaybe<Scalars['ID']>;
  salaryId?: InputMaybe<Scalars['ID']>;
  timesheetId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of ApprovePayrollItem. */
export type ApprovePayrollItemPayload = {
  __typename?: 'ApprovePayrollItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payrollItem?: Maybe<PayrollItem>;
};

/** Autogenerated input type of AutoLoginWithLink */
export type AutoLoginWithLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** the link's token */
  token: Scalars['String'];
};

/** Autogenerated return type of AutoLoginWithLink. */
export type AutoLoginWithLinkPayload = {
  __typename?: 'AutoLoginWithLinkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
  link?: Maybe<Link>;
  loginPerformed?: Maybe<Scalars['Boolean']>;
};

export type BackgroundCheck = Node & {
  __typename?: 'BackgroundCheck';
  completedAt?: Maybe<Scalars['DateTime']>;
  contracts?: Maybe<ContractConnection>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firm?: Maybe<Firm>;
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  invoiceItem?: Maybe<InvoiceItem>;
  lastName?: Maybe<Scalars['String']>;
  requestedBy?: Maybe<User>;
  status: BackgroundCheckStatusEnum;
  user?: Maybe<User>;
};


export type BackgroundCheckContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for BackgroundCheck. */
export type BackgroundCheckConnection = {
  __typename?: 'BackgroundCheckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BackgroundCheckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BackgroundCheck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type BackgroundCheckEdge = {
  __typename?: 'BackgroundCheckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BackgroundCheck>;
};

export enum BackgroundCheckStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing',
  Successful = 'successful',
  Waiting = 'waiting'
}

export type BackgroundChecksFilters = {
  status?: InputMaybe<BackgroundCheckStatusEnum>;
};

export enum BackgroundThemeEnum {
  Default = 'default',
  Light = 'light'
}

export type BankTransferDetails = {
  __typename?: 'BankTransferDetails';
  achAccountNumber?: Maybe<Scalars['String']>;
  achRoutingNumber?: Maybe<Scalars['String']>;
  institutionName?: Maybe<Scalars['String']>;
  swiftCode?: Maybe<Scalars['String']>;
};

export type BillingPlan = Node & {
  __typename?: 'BillingPlan';
  allowAtsJobIntegrations?: Maybe<Scalars['Boolean']>;
  allowBackgroundChecks?: Maybe<Scalars['Boolean']>;
  allowCareerPageIntegration?: Maybe<Scalars['Boolean']>;
  allowFlexhireRecruiters?: Maybe<Scalars['Boolean']>;
  allowMultipleManagers?: Maybe<Scalars['Boolean']>;
  allowPaymentsDisabledContracts?: Maybe<Scalars['Boolean']>;
  contractsHireMinMarginUsd?: Maybe<Scalars['Float']>;
  contractsHireSourcedByClientMargin?: Maybe<Scalars['Float']>;
  contractsHireSourcedByFlexhireMargin?: Maybe<Scalars['Float']>;
  contractsInvitationMargin?: Maybe<Scalars['Float']>;
  customerSuccessRep?: Maybe<Scalars['Boolean']>;
  dailyFlexhireRecruiterPerJobFeeUsd?: Maybe<Scalars['Float']>;
  dailyInviteContractFeeUsd?: Maybe<Scalars['Float']>;
  dailyJobFeeUsd?: Maybe<Scalars['Float']>;
  dailyManagerFeeUsd?: Maybe<Scalars['Float']>;
  dailyPaymentsDisabledContractFeeUsd?: Maybe<Scalars['Float']>;
  dailyPlanFeeUsd?: Maybe<Scalars['Float']>;
  dailySourcedByClientHireContractFeeUsd?: Maybe<Scalars['Float']>;
  dailySourcedByFlexhireHireContractFeeUsd?: Maybe<Scalars['Float']>;
  freePaymentsDisabledContractsLimit?: Maybe<Scalars['Int']>;
  hidden?: Maybe<Scalars['Boolean']>;
  highlighted?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  maxCandidates?: Maybe<Scalars['Int']>;
  minimumManagers?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  paymentMethodTypes?: Maybe<Array<PaymentMethodTypeLiteral>>;
  rawId?: Maybe<Scalars['Int']>;
};

export type BlogCategory = Node & {
  __typename?: 'BlogCategory';
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  posts?: Maybe<BlogPostConnection>;
  /** @deprecated used only by some legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
  subcategories?: Maybe<BlogSubcategoryConnection>;
};


export type BlogCategoryPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type BlogCategorySubcategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for BlogCategory. */
export type BlogCategoryConnection = {
  __typename?: 'BlogCategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlogCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BlogCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type BlogCategoryEdge = {
  __typename?: 'BlogCategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BlogCategory>;
};

export type BlogPost = Node & {
  __typename?: 'BlogPost';
  blogCategory?: Maybe<BlogCategory>;
  blogSubcategory?: Maybe<BlogSubcategory>;
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  excerpt?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** @deprecated used only by some legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<BlogPostStatusEnum>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
  video?: Maybe<Video>;
};

/** The connection type for BlogPost. */
export type BlogPostConnection = {
  __typename?: 'BlogPostConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlogPostEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BlogPost>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type BlogPostEdge = {
  __typename?: 'BlogPostEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BlogPost>;
};

export enum BlogPostStatusEnum {
  Approved = 'approved',
  Draft = 'draft',
  Published = 'published'
}

export type BlogSubcategory = Node & {
  __typename?: 'BlogSubcategory';
  category?: Maybe<BlogCategory>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  posts?: Maybe<BlogPost>;
  /** @deprecated used only by some legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
};

/** The connection type for BlogSubcategory. */
export type BlogSubcategoryConnection = {
  __typename?: 'BlogSubcategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlogSubcategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BlogSubcategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type BlogSubcategoryEdge = {
  __typename?: 'BlogSubcategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BlogSubcategory>;
};

export type Bonus = Node & {
  __typename?: 'Bonus';
  contract?: Maybe<Contract>;
  currency?: Maybe<Currency>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['Date']>;
  id: Scalars['ID'];
  itemType?: Maybe<Scalars['String']>;
  payrollItem?: Maybe<PayrollItem>;
  startDate?: Maybe<Scalars['Date']>;
  totalToPayClient?: Maybe<Money>;
  totalToPayFreelancer?: Maybe<Money>;
};

/** The connection type for Bonus. */
export type BonusConnection = {
  __typename?: 'BonusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BonusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Bonus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type BonusEdge = {
  __typename?: 'BonusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Bonus>;
};

export type BonusPreview = {
  __typename?: 'BonusPreview';
  clientBonus?: Maybe<Money>;
  memberBonus?: Maybe<Money>;
};

export type BonusPreviewAttributes = {
  clientBonus?: InputMaybe<MoneyInput>;
  memberBonus?: InputMaybe<MoneyInput>;
};

export type BonusesFilters = {
  amount?: InputMaybe<Scalars['Int']>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated use pipelineStatus instead */
  clientStatus?: InputMaybe<PayrollItemClientStatus>;
  contractStatuses?: InputMaybe<Array<ContractStatus>>;
  date?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  /** @deprecated use pipelineStatus instead */
  freelancerStatus?: InputMaybe<PayrollItemFreelancerStatus>;
  invoiceNum?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  pipelineStatus?: InputMaybe<PayrollItemPipelineStatus>;
  startDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<PayrollItemStatus>;
};

/** Autogenerated input type of CancelApplication */
export type CancelApplicationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CancelApplication. */
export type CancelApplicationPayload = {
  __typename?: 'CancelApplicationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** represents a match between a Flexhire member and a Job */
export type Candidate = Node & {
  __typename?: 'Candidate';
  /** the associated contract for this member and job, if any */
  contract?: Maybe<Contract>;
  freelancer: User;
  id: Scalars['ID'];
  /** if true, the user has been invited to apply to this job by the client */
  invitedToJob?: Maybe<Scalars['Boolean']>;
  job?: Maybe<Job>;
  /** reasons for why the member can't apply to this job, if any */
  jobIncompatibilityReasons?: Maybe<Array<Scalars['String']>>;
};

/** The connection type for Candidate. */
export type CandidateConnection = {
  __typename?: 'CandidateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CandidateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Candidate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type CandidateEdge = {
  __typename?: 'CandidateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Candidate>;
};

export type CandidateToNotify = Node & {
  __typename?: 'CandidateToNotify';
  id: Scalars['ID'];
  rawId?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
};

export type CandidateToNotifyAttributes = {
  rawId?: InputMaybe<Scalars['Int']>;
};

export type CandidatesFilters = {
  adminMode?: InputMaybe<Scalars['Boolean']>;
  availableOnly?: InputMaybe<Scalars['Boolean']>;
  bookmarked?: InputMaybe<Scalars['Boolean']>;
  bookmarkedByUserId?: InputMaybe<Scalars['Int']>;
  canWorkInTheUs?: InputMaybe<Scalars['Boolean']>;
  contractStatus?: InputMaybe<Scalars['String']>;
  countries?: InputMaybe<Array<Scalars['String']>>;
  distanceMiles?: InputMaybe<Scalars['Float']>;
  distanceOriginLatitude?: InputMaybe<Scalars['Float']>;
  distanceOriginLongitude?: InputMaybe<Scalars['Float']>;
  excludeHidden?: InputMaybe<Scalars['Boolean']>;
  experience?: InputMaybe<Scalars['Int']>;
  freelancerSubtypes?: InputMaybe<Array<CandidatesFiltersFreelancerSubtype>>;
  hasAnswers?: InputMaybe<Scalars['Boolean']>;
  hasProjectSubmission?: InputMaybe<Scalars['Boolean']>;
  hasVideoIntroduction?: InputMaybe<Scalars['Boolean']>;
  jobsIds?: InputMaybe<Array<Scalars['Int']>>;
  locationType?: InputMaybe<Scalars['String']>;
  managedTeamSizes?: InputMaybe<Array<Scalars['String']>>;
  managedTeams?: InputMaybe<Scalars['Boolean']>;
  maxAnnualCompensation?: InputMaybe<Scalars['Int']>;
  maxClientRate?: InputMaybe<Scalars['Float']>;
  maxUniversityRank?: InputMaybe<Scalars['Int']>;
  missingAnswers?: InputMaybe<Scalars['Boolean']>;
  missingProjectSubmission?: InputMaybe<Scalars['Boolean']>;
  missingVideoIntroduction?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  positionTypes?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  showNotNotified?: InputMaybe<Scalars['Boolean']>;
  showNotified?: InputMaybe<Scalars['Boolean']>;
  skills?: InputMaybe<Array<SkillFilter>>;
  timezone?: InputMaybe<Scalars['Int']>;
  timezoneRange?: InputMaybe<Scalars['Int']>;
  university?: InputMaybe<Scalars['String']>;
  verifiedOnly?: InputMaybe<Scalars['Boolean']>;
};

export type CandidatesFiltersFreelancerSubtype = {
  groupIndex?: InputMaybe<Scalars['Int']>;
  id: Scalars['Int'];
  name?: InputMaybe<Scalars['String']>;
};

export type ChatBot = Node & {
  __typename?: 'ChatBot';
  avatarUrl?: Maybe<Scalars['String']>;
  directChatThread?: Maybe<ChatThread>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export type ChatMessage = Node & {
  __typename?: 'ChatMessage';
  chatThread: ChatThread;
  contract?: Maybe<Contract>;
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  label?: Maybe<Scalars['String']>;
  message: Scalars['String'];
  rawId?: Maybe<Scalars['Int']>;
  sender: Recipient;
  /** @deprecated use the sender field */
  user?: Maybe<User>;
};

/** The connection type for ChatMessage. */
export type ChatMessageConnection = {
  __typename?: 'ChatMessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ChatMessageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ChatMessage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ChatMessageEdge = {
  __typename?: 'ChatMessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ChatMessage>;
};

export type ChatMessageFilters = {
  excludeSelf?: InputMaybe<Scalars['Boolean']>;
  /** if true, only returns messages unread by current user. Returns nothing if used while logged out */
  unread?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of ChatMessageReceived. */
export type ChatMessageReceivedPayload = {
  __typename?: 'ChatMessageReceivedPayload';
  chatMessage?: Maybe<ChatMessage>;
};

export type ChatThread = Node & {
  __typename?: 'ChatThread';
  avatarUrl?: Maybe<Scalars['String']>;
  chatBots: Array<ChatBot>;
  chatMessages?: Maybe<ChatMessageConnection>;
  createdAt?: Maybe<Scalars['DateTime']>;
  defaultTitle?: Maybe<Scalars['String']>;
  enableMeetingRoom?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  lastActivityAt?: Maybe<Scalars['DateTime']>;
  meetingRoom?: Maybe<Scalars['String']>;
  /** @deprecated use the recipient field */
  otherUser?: Maybe<User>;
  rawId?: Maybe<Scalars['Int']>;
  recipient?: Maybe<Recipient>;
  threadType: ChatThreadTypeEnum;
  title?: Maybe<Scalars['String']>;
  users: Array<User>;
};


export type ChatThreadChatMessagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ChatMessageFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ChatThread. */
export type ChatThreadConnection = {
  __typename?: 'ChatThreadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ChatThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ChatThread>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ChatThreadEdge = {
  __typename?: 'ChatThreadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ChatThread>;
};

export enum ChatThreadTypeEnum {
  Direct = 'direct',
  Group = 'group'
}

/** Autogenerated return type of ChatThreadUpdated. */
export type ChatThreadUpdatedPayload = {
  __typename?: 'ChatThreadUpdatedPayload';
  chatThread?: Maybe<ChatThread>;
};

/** Autogenerated input type of CheckoutInvoice */
export type CheckoutInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  invoiceId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  invoiceRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of CheckoutInvoice. */
export type CheckoutInvoicePayload = {
  __typename?: 'CheckoutInvoicePayload';
  /** @deprecated use stripeCharge.status instead */
  chargeStatus?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  invoice?: Maybe<Invoice>;
  paymentMethod?: Maybe<PaymentMethod>;
  /** @deprecated use paymentMethod.paymentMethodType instead */
  paymentMethodType?: Maybe<PaymentMethodTypeLiteral>;
  stripeCharge?: Maybe<StripeCharge>;
};

/** Autogenerated input type of CloseJob */
export type CloseJobInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  jobId: Scalars['ID'];
};

/** Autogenerated return type of CloseJob. */
export type CloseJobPayload = {
  __typename?: 'CloseJobPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  job?: Maybe<Job>;
};

/** Autogenerated input type of CompleteReference */
export type CompleteReferenceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  completeReferenceToken: Scalars['String'];
  email?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  otherRelation?: InputMaybe<Scalars['String']>;
  ratingProfessional: Scalars['Int'];
  referenceName?: InputMaybe<Scalars['String']>;
  relation: ReferenceRelationEnum;
  wouldRecommend: Scalars['Boolean'];
};

/** Autogenerated return type of CompleteReference. */
export type CompleteReferencePayload = {
  __typename?: 'CompleteReferencePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CompleteSignature */
export type CompleteSignatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  signatureId: Scalars['String'];
};

/** Autogenerated return type of CompleteSignature. */
export type CompleteSignaturePayload = {
  __typename?: 'CompleteSignaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  signature?: Maybe<Signature>;
};

/** Autogenerated input type of CompleteVideoUpload */
export type CompleteVideoUploadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  videoId: Scalars['ID'];
};

/** Autogenerated return type of CompleteVideoUpload. */
export type CompleteVideoUploadPayload = {
  __typename?: 'CompleteVideoUploadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  video?: Maybe<Video>;
};

export type Configuration = {
  __typename?: 'Configuration';
  advertisingProviders?: Maybe<Array<Scalars['String']>>;
  allowJobsWithNoRates?: Maybe<Scalars['Boolean']>;
  backgroundCheckPriceUsd?: Maybe<Scalars['Float']>;
  creditCardFixedFee?: Maybe<Scalars['Float']>;
  creditCardPercentageFee?: Maybe<Scalars['Float']>;
  currenciesExemptFromConversionFee?: Maybe<Array<Scalars['String']>>;
  currencyConversionPercentageFee?: Maybe<Scalars['Float']>;
  enableAutoBonuses?: Maybe<Scalars['Boolean']>;
  enableCompanyVideos?: Maybe<Scalars['Boolean']>;
  enableContractAgreements?: Maybe<Scalars['Boolean']>;
  enableHiringManager?: Maybe<Scalars['Boolean']>;
  enablePwaInstall?: Maybe<Scalars['Boolean']>;
  enableServiceWorker?: Maybe<Scalars['Boolean']>;
  enableServiceWorkerAutoSkipWaiting?: Maybe<Scalars['Boolean']>;
  enableServiceWorkerUpdateDetection?: Maybe<Scalars['Boolean']>;
  frontendBuildId?: Maybe<Scalars['String']>;
  invitationMinClientRateUsd?: Maybe<Scalars['Float']>;
  jobsMinClientRate?: Maybe<Money>;
  /** @deprecated being phased out, don't use */
  jobsMinClientRateUsd?: Maybe<Scalars['Float']>;
  maxCandidates?: Maybe<Scalars['Int']>;
  maxTimelineEntries?: Maybe<Scalars['Int']>;
  minHourlyRate?: Maybe<Money>;
  /** @deprecated being phased out, don't use */
  minHourlyRateUsd?: Maybe<Scalars['Float']>;
  oauthSignupProviders?: Maybe<Array<Scalars['String']>>;
  paymentMethodTypes?: Maybe<Array<Scalars['String']>>;
  payoutMethodTypes?: Maybe<Array<PayoutMethodTypeEnum>>;
  profileFeedbackParticipants?: Maybe<Array<User>>;
  profileFeedbackParticipantsIds?: Maybe<Array<Scalars['Int']>>;
  sepaLimit?: Maybe<Scalars['Float']>;
  stripeConnectSupportedCountries?: Maybe<Array<Scalars['String']>>;
  /** @deprecated use top level currencies field */
  supportedCurrencies?: Maybe<Array<Currency>>;
  useVideoCdn?: Maybe<Scalars['Boolean']>;
  videoCdnUrl?: Maybe<Scalars['String']>;
  videoMaxDuration?: Maybe<Scalars['Float']>;
  videoMaxDurationCompany?: Maybe<Scalars['Float']>;
  videoMinDuration?: Maybe<Scalars['Float']>;
};

/** Autogenerated input type of ConfirmEmail */
export type ConfirmEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  token: Scalars['String'];
};

/** Autogenerated return type of ConfirmEmail. */
export type ConfirmEmailPayload = {
  __typename?: 'ConfirmEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export type Contract = Node & {
  __typename?: 'Contract';
  allowHireAccess?: Maybe<Scalars['Boolean']>;
  allowManageAccess?: Maybe<Scalars['Boolean']>;
  allowTextualAnswers?: Maybe<Scalars['Boolean']>;
  answers?: Maybe<Array<Video>>;
  applicantSource?: Maybe<Scalars['String']>;
  availabilityType?: Maybe<Array<Scalars['String']>>;
  backgroundCheck?: Maybe<BackgroundCheck>;
  bonusClientRate?: Maybe<Money>;
  bonusPeriod?: Maybe<ContractBonusPeriod>;
  /** preview the client and member rates of a bonus */
  bonusPreview?: Maybe<BonusPreview>;
  bookmarked?: Maybe<Scalars['Boolean']>;
  calendlyUrl?: Maybe<Scalars['String']>;
  /** get the corresponding Candidate object for this contract */
  candidate?: Maybe<Candidate>;
  city?: Maybe<Scalars['String']>;
  client?: Maybe<User>;
  clientAgreesTerms?: Maybe<Scalars['Boolean']>;
  clientRate?: Maybe<Money>;
  clientRejectionComments?: Maybe<Scalars['String']>;
  clientRejectionMessage?: Maybe<Scalars['String']>;
  clientRejectionReason?: Maybe<Scalars['String']>;
  contractFeedbacks?: Maybe<Array<ContractFeedback>>;
  contractIntroductionSentAt?: Maybe<Scalars['DateTime']>;
  contractRate?: Maybe<ContractRate>;
  contractRates?: Maybe<ContractRateConnection>;
  contractRequests?: Maybe<Array<ContractRequest>>;
  contractType?: Maybe<ContractTypeEnum>;
  contractorAgreementSignature?: Maybe<Signature>;
  contractorStatementOfWorkSignature?: Maybe<Signature>;
  country?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  currency: Currency;
  dailyFee?: Maybe<Money>;
  defaultDistance?: Maybe<Scalars['Float']>;
  /** true if current user can delete this contract */
  deletable?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  disableMinUsdMarginLimit?: Maybe<Scalars['Boolean']>;
  discountId?: Maybe<Scalars['Int']>;
  /** true if current user can edit this contract */
  editable?: Maybe<Scalars['Boolean']>;
  employeeType?: Maybe<EmployeeTypeEnum>;
  employerOfRecordTemplate?: Maybe<EmployerOfRecordTemplate>;
  enableTimesheets?: Maybe<Scalars['Boolean']>;
  endDate?: Maybe<Scalars['Date']>;
  estimatedNextSalaryPayoutDate?: Maybe<Scalars['DateTime']>;
  firm?: Maybe<Firm>;
  freelancer?: Maybe<User>;
  freelancerAgreesTerms?: Maybe<Scalars['Boolean']>;
  freelancerContactEmail?: Maybe<Scalars['String']>;
  freelancerEmail?: Maybe<Scalars['String']>;
  freelancerFeedback?: Maybe<Scalars['String']>;
  freelancerFirstName?: Maybe<Scalars['String']>;
  freelancerLastName?: Maybe<Scalars['String']>;
  freelancerMessage?: Maybe<Scalars['String']>;
  freelancerName?: Maybe<Scalars['String']>;
  freelancerPhone?: Maybe<Scalars['String']>;
  freelancerRate?: Maybe<Money>;
  freelancerTimezoneName?: Maybe<Scalars['String']>;
  fullAddress?: Maybe<Scalars['String']>;
  hidden?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  inheritor?: Maybe<User>;
  interviewAcceptedAt?: Maybe<Scalars['DateTime']>;
  interviewDate?: Maybe<Scalars['DateTime']>;
  interviewDate1?: Maybe<Scalars['DateTime']>;
  interviewDate2?: Maybe<Scalars['DateTime']>;
  interviewDate3?: Maybe<Scalars['DateTime']>;
  interviewDate4?: Maybe<Scalars['DateTime']>;
  interviewNote?: Maybe<Scalars['String']>;
  interviewSchedulingMethod?: Maybe<Scalars['String']>;
  interviewTimezone?: Maybe<Scalars['String']>;
  interviewerEmail?: Maybe<Scalars['String']>;
  interviewerName?: Maybe<Scalars['String']>;
  interviewerRole?: Maybe<Scalars['String']>;
  invitationType?: Maybe<InvitationTypeEnum>;
  invitedBy?: Maybe<User>;
  invitedToApplyAt?: Maybe<Scalars['DateTime']>;
  invoiceRecipient?: Maybe<User>;
  isFirmAdmin?: Maybe<Scalars['Boolean']>;
  isManager?: Maybe<Scalars['Boolean']>;
  job?: Maybe<Job>;
  jobApplicationNotifiedToAdminsAt?: Maybe<Scalars['DateTime']>;
  jobApplicationReminderSentAt?: Maybe<Scalars['DateTime']>;
  jobApplicationSentAt?: Maybe<Scalars['DateTime']>;
  jobApplicationSentByFreelancerAt?: Maybe<Scalars['DateTime']>;
  jobOpportunitySentAt?: Maybe<Scalars['DateTime']>;
  jobTimezone?: Maybe<Scalars['String']>;
  jobTitle?: Maybe<Scalars['String']>;
  lastInteractionAt?: Maybe<Scalars['DateTime']>;
  latitude?: Maybe<Scalars['Float']>;
  locationType?: Maybe<Scalars['String']>;
  longitude?: Maybe<Scalars['Float']>;
  managedOffPlatform?: Maybe<Scalars['Boolean']>;
  margin?: Maybe<Scalars['Float']>;
  minClientRate?: Maybe<Scalars['Float']>;
  minMarginUsd?: Maybe<Scalars['Float']>;
  negativeFeedbackCount?: Maybe<Scalars['Int']>;
  nextSalaryInvoiceDate?: Maybe<Scalars['DateTime']>;
  notifyChanges?: Maybe<Scalars['Boolean']>;
  offerNote?: Maybe<Scalars['String']>;
  paychecks?: Maybe<PaycheckConnection>;
  paymentMode?: Maybe<PaymentModeEnum>;
  paymentsEnabled?: Maybe<Scalars['Boolean']>;
  payrollItems?: Maybe<Array<PayrollItem>>;
  positionTypes?: Maybe<Array<Scalars['String']>>;
  positiveFeedbackCount?: Maybe<Scalars['Int']>;
  postInterviewRemindersSentAt?: Maybe<Scalars['DateTime']>;
  previousStatus?: Maybe<Scalars['String']>;
  profileJobIncompatibilityReasons?: Maybe<Array<Scalars['String']>>;
  projectLength?: Maybe<Scalars['String']>;
  projectLengthInMonths?: Maybe<Scalars['Int']>;
  projectSubmission?: Maybe<ProjectSubmission>;
  purchaseOrderNumber?: Maybe<Scalars['String']>;
  rateMode?: Maybe<RateMode>;
  rawId?: Maybe<Scalars['Int']>;
  /**
   * platform from which the applicant came from when applying to the job. Most
   * common values are linkedin, iframe (for iframe integration)
   */
  ref?: Maybe<Scalars['String']>;
  /** user which brought this applicant to the platform via referral code, if any */
  referer?: Maybe<User>;
  /** url from which the applicant came from when applying to the job */
  refererUrl?: Maybe<Scalars['String']>;
  referralOpportunitySentAt?: Maybe<Scalars['DateTime']>;
  region?: Maybe<Scalars['String']>;
  requestsStatus?: Maybe<ContractRequestsStatus>;
  requireApprovalForPayments?: Maybe<Scalars['Boolean']>;
  signableDocuments?: Maybe<Array<SignableDocument>>;
  sourcedByClient?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['Date']>;
  stats?: Maybe<PayrollStats>;
  status: ContractStatus;
  tags?: Maybe<Array<Tag>>;
  textualAnswers?: Maybe<Array<Answer>>;
  timesheets?: Maybe<TimesheetConnection>;
  token?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};


export type ContractBonusPreviewArgs = {
  input: BonusPreviewAttributes;
};


export type ContractContractRateArgs = {
  currentAt?: InputMaybe<Scalars['DateTime']>;
};


export type ContractContractRatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractRatesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ContractPaychecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PaychecksFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ContractTimesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<TimesheetsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export enum ContractBonusPeriod {
  /** grant a bonus every month */
  Monthly = 'monthly',
  /** grant a bonus every year */
  Yearly = 'yearly'
}

/** The connection type for Contract. */
export type ContractConnection = {
  __typename?: 'ContractConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContractEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Contract>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ContractEdge = {
  __typename?: 'ContractEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Contract>;
};

export type ContractFeedback = Node & {
  __typename?: 'ContractFeedback';
  contract?: Maybe<Contract>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  ratingPositive: Scalars['Boolean'];
  status?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};

export type ContractPreview = {
  __typename?: 'ContractPreview';
  clientRate?: Maybe<Money>;
  /** the existing contract being updated, or null for new contracts */
  contract?: Maybe<Contract>;
  contractType?: Maybe<ContractTypeEnum>;
  currency?: Maybe<Currency>;
  dailyFee?: Maybe<Money>;
  discountId?: Maybe<Scalars['Int']>;
  employerOfRecordTemplate?: Maybe<EmployerOfRecordTemplate>;
  freelancerFirstName?: Maybe<Scalars['String']>;
  freelancerRate?: Maybe<Money>;
  invitationType?: Maybe<InvitationTypeEnum>;
  margin?: Maybe<Scalars['Float']>;
  minClientRate?: Maybe<Money>;
  minMarginUsd?: Maybe<Scalars['Float']>;
  paymentsEnabled?: Maybe<Scalars['Boolean']>;
  rateMode?: Maybe<RateMode>;
};

export type ContractPreviewAttributes = {
  availabilityType?: InputMaybe<Array<Scalars['String']>>;
  clientId?: InputMaybe<Scalars['ID']>;
  clientRate?: InputMaybe<MoneyInput>;
  contractId?: InputMaybe<Scalars['ID']>;
  currency?: InputMaybe<Scalars['String']>;
  discountCode?: InputMaybe<Scalars['String']>;
  freelancerEmail?: InputMaybe<Scalars['String']>;
  freelancerId?: InputMaybe<Scalars['ID']>;
  freelancerRate?: InputMaybe<MoneyInput>;
  jobId?: InputMaybe<Scalars['ID']>;
  rateMode?: InputMaybe<RateMode>;
};

export type ContractRate = Node & {
  __typename?: 'ContractRate';
  clientRate?: Maybe<Money>;
  contract?: Maybe<Contract>;
  currency?: Maybe<Currency>;
  endsAt?: Maybe<Scalars['DateTime']>;
  freelancerRate?: Maybe<Money>;
  id: Scalars['ID'];
  margin?: Maybe<Scalars['Int']>;
  paymentMode?: Maybe<PaymentModeEnum>;
  rateMode?: Maybe<RateMode>;
  startedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for ContractRate. */
export type ContractRateConnection = {
  __typename?: 'ContractRateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContractRateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContractRate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ContractRateEdge = {
  __typename?: 'ContractRateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContractRate>;
};

export type ContractRatesFilters = {
  future?: InputMaybe<Scalars['Boolean']>;
  order?: InputMaybe<SortOrder>;
  past?: InputMaybe<Scalars['Boolean']>;
  sort?: InputMaybe<ContractRatesOrderEnum>;
};

export enum ContractRatesOrderEnum {
  StartedAt = 'started_at'
}

export type ContractRequest = Node & {
  __typename?: 'ContractRequest';
  allowTextualAnswers?: Maybe<Scalars['Boolean']>;
  contract?: Maybe<Contract>;
  id: Scalars['ID'];
  project?: Maybe<Project>;
  projectSubmission?: Maybe<ProjectSubmission>;
  question?: Maybe<Question>;
  requestType?: Maybe<ContractRequestTypeEnum>;
  status?: Maybe<ContractRequestStatusEnum>;
};

export enum ContractRequestStatusEnum {
  /** the member has completed the request */
  Completed = 'completed',
  /** the request has been sent to the member */
  Pending = 'pending',
  /** the member has declined to complete the request */
  Rejected = 'rejected',
  /** the member has accepted the request */
  Started = 'started'
}

export enum ContractRequestTypeEnum {
  /** provide an answer to a question */
  Answer = 'answer',
  /** provide a submission for a project */
  ProjectSubmission = 'project_submission',
  /** provide a video introduction for your profile */
  VideoIntroduction = 'video_introduction'
}

export enum ContractRequestsStatus {
  /** all requests have been completed */
  Completed = 'completed',
  /** requests have been made */
  Pending = 'pending',
  /** member has declined to complete requests */
  Rejected = 'rejected',
  /** member has accepted the requests */
  Started = 'started'
}

export enum ContractStageEnum {
  Contract = 'contract',
  Interview = 'interview',
  Offer = 'offer'
}

/** aggregate counts of contracts */
export type ContractStats = {
  __typename?: 'ContractStats';
  interviewsActionableCount: Scalars['Int'];
  interviewsTotalCount: Scalars['Int'];
  offersActionableCount: Scalars['Int'];
  offersTotalCount: Scalars['Int'];
};

export enum ContractStatus {
  /** contract is active and ongoing */
  Active = 'active',
  /** expired contract has been deleted */
  Deleted = 'deleted',
  /** active/paused contract has ended */
  Expired = 'expired',
  /** member has declined invitation to apply */
  FreelancerNotInterested = 'freelancer_not_interested',
  /** interview request has been accepted by the member */
  InterviewAccepted = 'interview_accepted',
  /** interview request has been rejected by the member */
  InterviewRejected = 'interview_rejected',
  /** member has started applying to the job */
  JobApplicationDraft = 'job_application_draft',
  /** member has been invited by the client to apply to the job */
  JobApplicationInvited = 'job_application_invited',
  /** member has sent the job application */
  JobApplicationSent = 'job_application_sent',
  /** member has visited the job page */
  JobViewed = 'job_viewed',
  /** an offer has been made via hire pipeline or by inviting an off-platform user */
  OfferMade = 'offer_made',
  /** the member has turned down the offer */
  OfferRejected = 'offer_rejected',
  /** contract is active and ongoing, but timesheet submission and payments are paused */
  Paused = 'paused',
  /** interview has been requested by the client */
  Pending = 'pending',
  /** potential referrer or applicant for the job */
  Potential = 'potential',
  /** during the hiring process, the member has been rejected by the client or an offer has been withdrawn */
  Rejected = 'rejected'
}

export enum ContractTypeEnum {
  /** freelancer that gets paid the full amount and handles their own taxes */
  Contractor = 'contractor',
  /** registered employee with an Employer of Record */
  Employee = 'employee'
}

/** Autogenerated return type of ContractUpdated. */
export type ContractUpdatedPayload = {
  __typename?: 'ContractUpdatedPayload';
  contract?: Maybe<Contract>;
};

export type ContractsFilters = {
  adminsOnly?: InputMaybe<Scalars['Boolean']>;
  approvalType?: InputMaybe<ApprovalTypeEnum>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated used only for legacy frontend code */
  clientRawId?: InputMaybe<Scalars['Int']>;
  contractType?: InputMaybe<ContractTypeEnum>;
  enableTimesheets?: InputMaybe<Scalars['Boolean']>;
  excludeSelf?: InputMaybe<Scalars['Boolean']>;
  firmId?: InputMaybe<Scalars['ID']>;
  freelancerId?: InputMaybe<Scalars['ID']>;
  /** @deprecated used only for legacy frontend code */
  freelancerRawIdOrSlug?: InputMaybe<Scalars['String']>;
  invitationType?: InputMaybe<InvitationTypeEnum>;
  jobId?: InputMaybe<Scalars['ID']>;
  managersOnly?: InputMaybe<Scalars['Boolean']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  paymentMode?: InputMaybe<PaymentModeEnum>;
  paymentsEnabled?: InputMaybe<Scalars['Boolean']>;
  skillsIds?: InputMaybe<Array<Scalars['Int']>>;
  stage?: InputMaybe<ContractStageEnum>;
  startDateInPast?: InputMaybe<Scalars['Boolean']>;
  statuses?: InputMaybe<Array<ContractStatus>>;
  tagsIds?: InputMaybe<Array<Scalars['Int']>>;
  withJobScreening?: InputMaybe<Scalars['Boolean']>;
  withoutJobScreening?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of CreateAnswer */
export type CreateAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  questionId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  questionRawId?: InputMaybe<Scalars['Int']>;
  textualAnswer: Scalars['String'];
};

/** Autogenerated return type of CreateAnswer. */
export type CreateAnswerPayload = {
  __typename?: 'CreateAnswerPayload';
  answer?: Maybe<Answer>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of CreateApiKey */
export type CreateApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateApiKey. */
export type CreateApiKeyPayload = {
  __typename?: 'CreateApiKeyPayload';
  apiKey?: Maybe<ApiKey>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** this is the only way you can read the actual key! Make sure not to lose it */
  key?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateBackgroundCheck */
export type CreateBackgroundCheckInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  firmId: Scalars['ID'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** Autogenerated return type of CreateBackgroundCheck. */
export type CreateBackgroundCheckPayload = {
  __typename?: 'CreateBackgroundCheckPayload';
  backgroundCheck?: Maybe<BackgroundCheck>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of CreateBlogPost */
export type CreateBlogPostInput = {
  blogCategoryId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  blogCategoryRawId?: InputMaybe<Scalars['Int']>;
  blogSubcategoryId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  blogSubcategoryRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  videoId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  videoRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of CreateBlogPost. */
export type CreateBlogPostPayload = {
  __typename?: 'CreateBlogPostPayload';
  blogPost?: Maybe<BlogPost>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of CreateChatThread */
export type CreateChatThreadInput = {
  avatarUrl?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  userIds?: InputMaybe<Array<Scalars['ID']>>;
  /** @deprecated only used in legacy frontend code */
  userRawIds?: InputMaybe<Array<Scalars['Int']>>;
};

/** Autogenerated return type of CreateChatThread. */
export type CreateChatThreadPayload = {
  __typename?: 'CreateChatThreadPayload';
  chatThread?: Maybe<ChatThread>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of CreateContractRate */
export type CreateContractRateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRate: MoneyInput;
  contractId: Scalars['ID'];
  rateMode: RateMode;
  startedAt: Scalars['DateTime'];
};

/** Autogenerated return type of CreateContractRate. */
export type CreateContractRatePayload = {
  __typename?: 'CreateContractRatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contractRate?: Maybe<ContractRate>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of CreateCustomSkill */
export type CreateCustomSkillInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  freelancerTypeIds: Array<Scalars['Int']>;
  name: Scalars['String'];
};

/** Autogenerated return type of CreateCustomSkill. */
export type CreateCustomSkillPayload = {
  __typename?: 'CreateCustomSkillPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  skill?: Maybe<Skill>;
};

/** Autogenerated input type of CreateExpense */
export type CreateExpenseInput = {
  amount: MoneyInput;
  clientId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  expenseDate: Scalars['Date'];
  projectCode?: InputMaybe<Scalars['String']>;
  receiptUrl: Scalars['String'];
};

/** Autogenerated return type of CreateExpense. */
export type CreateExpensePayload = {
  __typename?: 'CreateExpensePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  expense?: Maybe<Expense>;
};

/** Autogenerated input type of CreateJobIntegration */
export type CreateJobIntegrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  firmId: Scalars['ID'];
  greenhouseJobId: Scalars['String'];
  integrationName: JobIntegrationNameForImportEnum;
};

/** Autogenerated return type of CreateJobIntegration. */
export type CreateJobIntegrationPayload = {
  __typename?: 'CreateJobIntegrationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  jobIntegration?: Maybe<JobIntegration>;
};

/** Autogenerated input type of CreateLink */
export type CreateLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  freelancerId?: InputMaybe<Scalars['ID']>;
  jobId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateLink. */
export type CreateLinkPayload = {
  __typename?: 'CreateLinkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  link?: Maybe<Link>;
};

/** Autogenerated input type of CreatePaymentMethod */
export type CreatePaymentMethodInput = {
  accountId?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  institutionName?: InputMaybe<Scalars['String']>;
  mask?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  paymentMethodType: PaymentMethodTypeLiteral;
  sessionId?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreatePaymentMethod. */
export type CreatePaymentMethodPayload = {
  __typename?: 'CreatePaymentMethodPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Autogenerated input type of CreateProjectSubmission */
export type CreateProjectSubmissionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  projectRawId?: InputMaybe<Scalars['Int']>;
  /** pass this to create a custom project */
  projectTitle?: InputMaybe<Scalars['String']>;
  screenshotUrl?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<ProjectSubmissionStatusEnum>;
  url: Scalars['String'];
};

/** Autogenerated return type of CreateProjectSubmission. */
export type CreateProjectSubmissionPayload = {
  __typename?: 'CreateProjectSubmissionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  projectSubmission?: Maybe<ProjectSubmission>;
};

/** Autogenerated input type of CreateQuestion */
export type CreateQuestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

/** Autogenerated return type of CreateQuestion. */
export type CreateQuestionPayload = {
  __typename?: 'CreateQuestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  question?: Maybe<Question>;
};

/** Autogenerated input type of CreateResume */
export type CreateResumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** if set, copy parsed data to profile, defaults to true */
  copyToProfile?: InputMaybe<Scalars['Boolean']>;
  /** original file name */
  filename?: InputMaybe<Scalars['String']>;
  /** original mime type */
  mimetype?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};

/** Autogenerated return type of CreateResume. */
export type CreateResumePayload = {
  __typename?: 'CreateResumePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  resume?: Maybe<Resume>;
};

/** Autogenerated input type of CreateSignableDocuments */
export type CreateSignableDocumentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId?: InputMaybe<Scalars['ID']>;
  documents: Array<SignableDocumentAttributes>;
};

/** Autogenerated return type of CreateSignableDocuments. */
export type CreateSignableDocumentsPayload = {
  __typename?: 'CreateSignableDocumentsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
  signableDocuments?: Maybe<Array<SignableDocument>>;
};

/** Autogenerated input type of CreateTimesheet */
export type CreateTimesheetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
  endDate?: InputMaybe<Scalars['Date']>;
  projectCodes?: InputMaybe<Array<Scalars['String']>>;
  startDate?: InputMaybe<Scalars['Date']>;
  submit?: InputMaybe<Scalars['Boolean']>;
  timesheetEntries?: InputMaybe<Array<TimesheetEntryAttributes>>;
};

/** Autogenerated return type of CreateTimesheet. */
export type CreateTimesheetPayload = {
  __typename?: 'CreateTimesheetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  timesheet?: Maybe<Timesheet>;
};

/** Autogenerated input type of CreateVideo */
export type CreateVideoInput = {
  /** if set, indicates the blog post for which the video is saved as the video content piece */
  blogPostId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  blogPostRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** expected video file extension; infers mime-type */
  extension: Scalars['String'];
  /** if set, indicates the firm for which the video is saved as the company page video */
  firmId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  firmRawId?: InputMaybe<Scalars['Int']>;
  /** if false, the video will not be displayed on the public profile */
  public?: InputMaybe<Scalars['Boolean']>;
  /** if set, indicates the question for which the video is saved as an answer */
  questionId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  questionRawId?: InputMaybe<Scalars['Int']>;
  /** if set, indicates the video type without knowing its associated model */
  videoType?: InputMaybe<VideoTypeEnum>;
};

/** Autogenerated return type of CreateVideo. */
export type CreateVideoPayload = {
  __typename?: 'CreateVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  uploadUrl?: Maybe<Scalars['String']>;
  video?: Maybe<Video>;
};

/** Autogenerated input type of CreateWebhook */
export type CreateWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** defaults to true. If false we will not send events to this webhook. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * HTTP POST requests with JSON bodies will be sent to this URL. The fields on
   * the body are 'event_name', 'timestamp' (unix integer format) and 'records'
   * (array of string IDs of related records)
   */
  url: Scalars['String'];
};

/** Autogenerated return type of CreateWebhook. */
export type CreateWebhookPayload = {
  __typename?: 'CreateWebhookPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** the webhook just created */
  webhook?: Maybe<Webhook>;
};

export type Currency = Node & {
  __typename?: 'Currency';
  allowContracts?: Maybe<Scalars['Boolean']>;
  allowInvoices?: Maybe<Scalars['Boolean']>;
  code?: Maybe<Scalars['String']>;
  conversionFee?: Maybe<Scalars['Boolean']>;
  iconUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  symbol?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeactivatePayoutMethod */
export type DeactivatePayoutMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payoutMethodId: Scalars['ID'];
};

/** Autogenerated return type of DeactivatePayoutMethod. */
export type DeactivatePayoutMethodPayload = {
  __typename?: 'DeactivatePayoutMethodPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payoutMethod?: Maybe<PayoutMethod>;
};

/** Autogenerated input type of DeleteAnswer */
export type DeleteAnswerInput = {
  answerId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  answerRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteAnswer. */
export type DeleteAnswerPayload = {
  __typename?: 'DeleteAnswerPayload';
  answer?: Maybe<Answer>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of DeleteApiKey */
export type DeleteApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteApiKey. */
export type DeleteApiKeyPayload = {
  __typename?: 'DeleteApiKeyPayload';
  apiKey?: Maybe<ApiKey>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of DeleteBlogPost */
export type DeleteBlogPostInput = {
  blogPostId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  blogPostRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteBlogPost. */
export type DeleteBlogPostPayload = {
  __typename?: 'DeleteBlogPostPayload';
  blogPost?: Maybe<BlogPost>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of DeleteContract */
export type DeleteContractInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  contractRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of DeleteContract. */
export type DeleteContractPayload = {
  __typename?: 'DeleteContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of DeleteContractRate */
export type DeleteContractRateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractRateId: Scalars['ID'];
};

/** Autogenerated return type of DeleteContractRate. */
export type DeleteContractRatePayload = {
  __typename?: 'DeleteContractRatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contractRate?: Maybe<ContractRate>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of DeletePaymentMethod */
export type DeletePaymentMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePaymentMethod. */
export type DeletePaymentMethodPayload = {
  __typename?: 'DeletePaymentMethodPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** the payment method just deleted */
  paymentMethod?: Maybe<PaymentMethod>;
};

/** Autogenerated input type of DeleteProjectSubmission */
export type DeleteProjectSubmissionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  projectSubmissionId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  projectSubmissionRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of DeleteProjectSubmission. */
export type DeleteProjectSubmissionPayload = {
  __typename?: 'DeleteProjectSubmissionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  projectSubmission?: Maybe<ProjectSubmission>;
};

/** Autogenerated input type of DeleteReference */
export type DeleteReferenceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  referenceId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  referenceRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of DeleteReference. */
export type DeleteReferencePayload = {
  __typename?: 'DeleteReferencePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  reference?: Maybe<Reference>;
};

/** Autogenerated input type of DeleteTimesheet */
export type DeleteTimesheetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  timesheetId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of DeleteTimesheet. */
export type DeleteTimesheetPayload = {
  __typename?: 'DeleteTimesheetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  timesheet?: Maybe<Timesheet>;
};

/** Autogenerated input type of DeleteUser */
export type DeleteUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** required when deleting own account */
  password?: InputMaybe<Scalars['String']>;
  /** omit this to delete your own account */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of DeleteUser. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of DeleteVideo */
export type DeleteVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  videoId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  videoRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of DeleteVideo. */
export type DeleteVideoPayload = {
  __typename?: 'DeleteVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  video?: Maybe<Video>;
};

/** Autogenerated input type of DeleteWebhook */
export type DeleteWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteWebhook. */
export type DeleteWebhookPayload = {
  __typename?: 'DeleteWebhookPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** the webhook just deleted */
  webhook?: Maybe<Webhook>;
};

/** a subscription to a category of emails. Can be used to customize email preferences */
export type EmailSubscription = Node & {
  __typename?: 'EmailSubscription';
  /** whether the subscription is active (meaning emails are sent) */
  active?: Maybe<Scalars['Boolean']>;
  /** if false, the subscription is not applicable for this user and the emails won't be sent */
  enabled?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  /** identifies which subscription it is */
  subscriptionName?: Maybe<SubscriptionName>;
  user?: Maybe<User>;
  /** whether the user has enabled this subscription. If false, the emails won't be sent. */
  userEnabled?: Maybe<Scalars['Boolean']>;
};

export enum EmployeeTypeEnum {
  /** flexhire is the employer of record for this employee */
  EmployedByFlexhire = 'employed_by_flexhire',
  /** flexhire is using a partner as employer of record for this employee */
  EmployedByPartner = 'employed_by_partner'
}

/** fee associated to an employer of record template */
export type EmployerOfRecordFee = Node & {
  __typename?: 'EmployerOfRecordFee';
  autoInclude?: Maybe<Scalars['Boolean']>;
  baseCharge?: Maybe<Money>;
  chargePercentage?: Maybe<Money>;
  currency?: Maybe<Currency>;
  employerOfRecordTemplate?: Maybe<EmployerOfRecordTemplate>;
  feeApplicationType?: Maybe<FeeApplicationTypeEnum>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  percentageType?: Maybe<Scalars['String']>;
  refundable?: Maybe<Scalars['Boolean']>;
};

/** Flexhire Associate/Partner company that handles EOR contracts for Flexhire */
export type EmployerOfRecordPartner = Node & {
  __typename?: 'EmployerOfRecordPartner';
  currency?: Maybe<Currency>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

/** set of common fees for employee-type contracts */
export type EmployerOfRecordTemplate = Node & {
  __typename?: 'EmployerOfRecordTemplate';
  employerOfRecordFees?: Maybe<Array<EmployerOfRecordFee>>;
  employerOfRecordPartner?: Maybe<EmployerOfRecordPartner>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type Error = {
  __typename?: 'Error';
  message: Scalars['String'];
};

export type Expense = Node & {
  __typename?: 'Expense';
  amount?: Maybe<Money>;
  contract?: Maybe<Contract>;
  currency?: Maybe<Currency>;
  description?: Maybe<Scalars['String']>;
  expenseDate?: Maybe<Scalars['Date']>;
  expenseType?: Maybe<ExpenseTypeEnum>;
  id: Scalars['ID'];
  itemNum?: Maybe<Scalars['Int']>;
  payrollItem?: Maybe<PayrollItem>;
  projectCode?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  receiptUrl?: Maybe<Scalars['String']>;
  timesheet?: Maybe<Timesheet>;
};

/** The connection type for Expense. */
export type ExpenseConnection = {
  __typename?: 'ExpenseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExpenseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Expense>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ExpenseEdge = {
  __typename?: 'ExpenseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Expense>;
};

export enum ExpenseTypeEnum {
  Capex = 'capex',
  Opex = 'opex'
}

export type ExpensesFilters = {
  clientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated use pipelineStatus instead */
  clientStatus?: InputMaybe<PayrollItemClientStatus>;
  contractStatuses?: InputMaybe<Array<ContractStatus>>;
  endDate?: InputMaybe<Scalars['Date']>;
  /** @deprecated use pipelineStatus instead */
  freelancerStatus?: InputMaybe<PayrollItemFreelancerStatus>;
  invoiceNum?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  pipelineStatus?: InputMaybe<PayrollItemPipelineStatus>;
  startDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<PayrollItemStatus>;
};

/** Autogenerated input type of ExpireContract */
export type ExpireContractInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
  /** if this contract is for a manager on the firm, specify who will inherit the managed assets. Defaults to the current user */
  inheritorId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of ExpireContract. */
export type ExpireContractPayload = {
  __typename?: 'ExpireContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

export enum FeeApplicationTypeEnum {
  /** this fee is applied at the end of the contract */
  Offboarding = 'offboarding',
  /** this fee is applied at the beginning of the contract */
  Onboarding = 'onboarding',
  /** this fee is applied monthly */
  Recurrent = 'recurrent'
}

/** Autogenerated input type of FetchStripeLoginUrl */
export type FetchStripeLoginUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payoutMethodId: Scalars['ID'];
};

/** Autogenerated return type of FetchStripeLoginUrl. */
export type FetchStripeLoginUrlPayload = {
  __typename?: 'FetchStripeLoginUrlPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  loginUrl?: Maybe<Scalars['String']>;
};

export type Firm = Node & {
  __typename?: 'Firm';
  activeMembersCount?: Maybe<Scalars['Int']>;
  additionalInvoiceText?: Maybe<Scalars['String']>;
  allowDisplayApplicantSource?: Maybe<Scalars['Boolean']>;
  allowInvoiceAutoCharge?: Maybe<Scalars['Boolean']>;
  allowJobsWithNoRates?: Maybe<Scalars['Boolean']>;
  allowNoPaymentMethod?: Maybe<Scalars['Boolean']>;
  applications?: Maybe<ApplicationsResults>;
  backgroundChecks?: Maybe<BackgroundCheckConnection>;
  backgroundTheme?: Maybe<BackgroundThemeEnum>;
  billingPlan?: Maybe<BillingPlan>;
  billingPlanStartedAt?: Maybe<Scalars['DateTime']>;
  bonuses?: Maybe<BonusConnection>;
  candidates?: Maybe<CandidateConnection>;
  /** the active contract the current user has with this firm */
  contract?: Maybe<Contract>;
  contractStats?: Maybe<ContractStats>;
  contracts?: Maybe<ContractConnection>;
  currency?: Maybe<Currency>;
  customerSuccessRep?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  emailList?: Maybe<Array<Scalars['String']>>;
  emailsForInvoices?: Maybe<Array<Scalars['String']>>;
  expenses?: Maybe<ExpenseConnection>;
  freelancerSubtypes?: Maybe<Array<FreelancerSubtype>>;
  greenhouseConfigured?: Maybe<Scalars['Boolean']>;
  /** @deprecated use firm.billingPlan values */
  hireSourcedByClientMargin?: Maybe<Scalars['Float']>;
  /** @deprecated use firm.billingPlan values */
  hireSourcedByFlexhireMargin?: Maybe<Scalars['Float']>;
  id: Scalars['ID'];
  instantBackgroundCheckPayment?: Maybe<Scalars['Boolean']>;
  internalRecruiter?: Maybe<User>;
  /** @deprecated use firm.billingPlan values */
  inviteMargin?: Maybe<Scalars['Float']>;
  /** @deprecated only used in legacy frontend code */
  invoice?: Maybe<Invoice>;
  invoiceSalariesInAdvance?: Maybe<Scalars['Boolean']>;
  invoiceSchedule?: Maybe<InvoiceSchedule>;
  invoices?: Maybe<InvoiceConnection>;
  invoicesSummary?: Maybe<InvoicesSummary>;
  job?: Maybe<Job>;
  jobs?: Maybe<JobConnection>;
  jobsForIntegration?: Maybe<JobForIntegrationConnection>;
  lastAutoInvoiceGenerationAt?: Maybe<Scalars['DateTime']>;
  legacyBilling?: Maybe<Scalars['Boolean']>;
  linkedinCompanyId?: Maybe<Scalars['String']>;
  logoUrl?: Maybe<Scalars['String']>;
  managerForNonPayrollFees?: Maybe<User>;
  member?: Maybe<Member>;
  minSalaryDaysToInvoice?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nextAutoInvoiceDate?: Maybe<Scalars['DateTime']>;
  paymentMethod?: Maybe<PaymentMethod>;
  paymentMethodTypes?: Maybe<Array<Scalars['String']>>;
  paymentMethods?: Maybe<Array<PaymentMethod>>;
  paymentNetTermsForNonPayroll?: Maybe<Scalars['Int']>;
  paymentNetTermsForPayroll?: Maybe<Scalars['Int']>;
  payoutMode?: Maybe<PayoutMode>;
  payrollItems?: Maybe<PayrollItemConnection>;
  purchaseOrderNumberForNonPayrollFees?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  salaries?: Maybe<SalaryConnection>;
  screening?: Maybe<ApplicationsResults>;
  /** true if current user has this firm in their firms list */
  self?: Maybe<Scalars['Boolean']>;
  signableDocuments?: Maybe<Array<SignableDocument>>;
  skills?: Maybe<Array<Skill>>;
  slug?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Tag>>;
  testJobIntegrationApiKey?: Maybe<ApiKeyTestResult>;
  timesheets?: Maybe<TimesheetConnection>;
  timezoneName?: Maybe<Scalars['String']>;
  unifyInvoicesInPreferredCurrency?: Maybe<Scalars['Boolean']>;
  users?: Maybe<Array<User>>;
  video?: Maybe<Video>;
  webhooks?: Maybe<Array<Webhook>>;
  website?: Maybe<Scalars['String']>;
};


export type FirmApplicationsArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


export type FirmBackgroundChecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<BackgroundChecksFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmBonusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<BonusesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmCandidatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<CandidatesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmEmailListArgs = {
  contractIds?: InputMaybe<Array<Scalars['ID']>>;
  contractRawIds?: InputMaybe<Array<Scalars['Int']>>;
};


export type FirmExpensesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ExpensesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmInvoiceArgs = {
  rawId?: InputMaybe<Scalars['Int']>;
};


export type FirmInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<InvoicesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmInvoicesSummaryArgs = {
  filters?: InputMaybe<InvoicesFilters>;
};


export type FirmJobArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type FirmJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<JobsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmJobsForIntegrationArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<JobForIntegrationFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmMemberArgs = {
  jobSlug?: InputMaybe<Scalars['String']>;
  profileSlugOrEmail?: InputMaybe<Scalars['String']>;
};


export type FirmPaymentMethodsArgs = {
  cardsOnly?: InputMaybe<Scalars['Boolean']>;
  exceptCards?: InputMaybe<Scalars['Boolean']>;
};


export type FirmPayrollItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PayrollItemsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmSalariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<SalariesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FirmScreeningArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


export type FirmTestJobIntegrationApiKeyArgs = {
  apiKey: Scalars['String'];
  integrationName: JobIntegrationNameForImportEnum;
};


export type FirmTimesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<TimesheetsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Firm. */
export type FirmConnection = {
  __typename?: 'FirmConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FirmEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Firm>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type FirmEdge = {
  __typename?: 'FirmEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Firm>;
};

/** Autogenerated return type of FirmUpdated. */
export type FirmUpdatedPayload = {
  __typename?: 'FirmUpdatedPayload';
  firm?: Maybe<Firm>;
};

/** Autogenerated input type of ForgotPassword */
export type ForgotPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
};

/** Autogenerated return type of ForgotPassword. */
export type ForgotPasswordPayload = {
  __typename?: 'ForgotPasswordPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  message?: Maybe<Scalars['String']>;
};

export type FreelancerSubtype = Node & {
  __typename?: 'FreelancerSubtype';
  featuredFreelancers?: Maybe<Array<User>>;
  featuredQuestions?: Maybe<Array<Question>>;
  freelancerType?: Maybe<FreelancerType>;
  iconUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  screeningQuestions?: Maybe<Array<Question>>;
  slug?: Maybe<Scalars['String']>;
};

export type FreelancerSubtypeAttributes = {
  groupIndex?: InputMaybe<Scalars['Int']>;
  rawId?: InputMaybe<Scalars['Int']>;
};

export type FreelancerType = Node & {
  __typename?: 'FreelancerType';
  featuredFreelancers?: Maybe<Array<User>>;
  featuredQuestions?: Maybe<Array<Question>>;
  freelancerSubtypes?: Maybe<Array<FreelancerSubtype>>;
  iconUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  jobsHaveCodeTests?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  profilesRequireSkills?: Maybe<Scalars['Boolean']>;
  rawId?: Maybe<Scalars['Int']>;
  screeningQuestions?: Maybe<Array<Question>>;
  skills?: Maybe<Array<Skill>>;
  slug?: Maybe<Scalars['String']>;
};


export type FreelancerTypeFeaturedFreelancersArgs = {
  skillSlug?: InputMaybe<Scalars['String']>;
};

export type FreelancerTypeAttributes = {
  rawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of FrontendVersionDeployed. */
export type FrontendVersionDeployedPayload = {
  __typename?: 'FrontendVersionDeployedPayload';
  buildId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of GrantBonus */
export type GrantBonusInput = {
  autoApprove?: InputMaybe<Scalars['Boolean']>;
  clientAmount: MoneyInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Date']>;
  startDate?: InputMaybe<Scalars['Date']>;
};

/** Autogenerated return type of GrantBonus. */
export type GrantBonusPayload = {
  __typename?: 'GrantBonusPayload';
  bonus?: Maybe<Bonus>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

export type Institute = Node & {
  __typename?: 'Institute';
  continent?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  nationalRank?: Maybe<Scalars['Int']>;
  rankingYear?: Maybe<Scalars['Int']>;
  /** @deprecated only used in legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  worldRank?: Maybe<Scalars['String']>;
};

/** The connection type for Institute. */
export type InstituteConnection = {
  __typename?: 'InstituteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InstituteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Institute>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type InstituteEdge = {
  __typename?: 'InstituteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Institute>;
};

export type InvitationRecipientAttributes = {
  freelancerData?: InputMaybe<InvitationRecipientData>;
  freelancerId?: InputMaybe<Scalars['ID']>;
  jobId?: InputMaybe<Scalars['ID']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  requestBackgroundCheck?: InputMaybe<Scalars['Boolean']>;
};

export type InvitationRecipientData = {
  email: Scalars['String'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

export enum InvitationTypeEnum {
  /** this contract was a hire that was executed via Flexhire */
  Hire = 'hire',
  /** this contract was a pre-existing hire that was then entered in Flexhire */
  Invitation = 'invitation'
}

/** Autogenerated input type of InviteFriend */
export type InviteFriendInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of InviteFriend. */
export type InviteFriendPayload = {
  __typename?: 'InviteFriendPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  sent: Scalars['Boolean'];
};

export type Invoice = Node & {
  __typename?: 'Invoice';
  /** payout to individuals is expected to be initiated at this time when payouts are configured to wait for client payment */
  assumedPayoutInitiationAt?: Maybe<Scalars['Date']>;
  bankTransferDetails?: Maybe<BankTransferDetails>;
  capitalExpenditureSubtotal?: Maybe<Money>;
  client?: Maybe<User>;
  /** true if the client has paid and payment has proccessed */
  clientPaid?: Maybe<Scalars['Boolean']>;
  /** timestamp of client payment completion */
  clientPaidAt?: Maybe<Scalars['DateTime']>;
  /** when the payment was initiated by the customer */
  clientPaymentStartedAt?: Maybe<Scalars['DateTime']>;
  /** status value for the customer */
  clientStatus?: Maybe<InvoiceClientStatus>;
  createdAt?: Maybe<Scalars['DateTime']>;
  /** url to download the CSV version */
  csvUrl?: Maybe<Scalars['String']>;
  currency?: Maybe<Currency>;
  /** deadline for when client payment must be initiated */
  dueDate?: Maybe<Scalars['Date']>;
  emailedAt?: Maybe<Scalars['DateTime']>;
  /** end of associated billing period */
  endDate?: Maybe<Scalars['Date']>;
  expenses?: Maybe<Array<Expense>>;
  expensesAmount?: Maybe<Money>;
  firm?: Maybe<Firm>;
  id: Scalars['ID'];
  /** date of issue */
  invoiceDate?: Maybe<Scalars['DateTime']>;
  invoiceItems?: Maybe<Array<InvoiceItem>>;
  invoiceItemsExchangeRates?: Maybe<Array<InvoiceExchangeRate>>;
  invoiceItemsSubtotal?: Maybe<Money>;
  /** invoice number */
  invoiceNum?: Maybe<Scalars['Int']>;
  isPaymentProcessing?: Maybe<Scalars['Boolean']>;
  lastEmailedAt?: Maybe<Scalars['DateTime']>;
  operatingExpenditureSubtotal?: Maybe<Money>;
  overdue?: Maybe<Scalars['Boolean']>;
  /** preview the payment for this invoice */
  paymentPreview?: Maybe<InvoicePaymentPreview>;
  paymentProcessingFeeIncluded?: Maybe<Scalars['Boolean']>;
  /** @deprecated use clientPaymentStartedAt */
  paymentStartedAt?: Maybe<Scalars['DateTime']>;
  /**
   * payout to individuals is expected to be initiated before this date, when
   * payouts are configured to not wait for client payment
   */
  payoutDueDate?: Maybe<Scalars['Date']>;
  /** url to download the PDF version */
  pdfUrl?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  salaries?: Maybe<Array<Salary>>;
  /** start of associated billing period */
  startDate?: Maybe<Scalars['Date']>;
  /** raw status */
  status: InvoiceStatus;
  timesheets?: Maybe<Array<Timesheet>>;
  /** unique string token to identify this invoice */
  token?: Maybe<Scalars['String']>;
  totalToPayClient?: Maybe<Money>;
  unassignedExpenditureSubtotal?: Maybe<Money>;
};


export type InvoicePaymentPreviewArgs = {
  paymentMethodId?: InputMaybe<Scalars['ID']>;
};

export enum InvoiceClientStatus {
  /** the invoice is still being built and is not complete */
  Draft = 'draft',
  /** the invoice has been issued, but not emailed to the firm yet */
  NotRequested = 'not_requested',
  /** the invoice was due in the past but the customer payment has not been initiated yet */
  Overdue = 'overdue',
  /** the customer payment has completed */
  Paid = 'paid',
  /** the customer payment has been initiated but has not completed yet */
  PaymentProcessing = 'payment_processing',
  /** the invoice has been issued and emailed */
  Requested = 'requested',
  /** the invoice has been voided */
  Void = 'void'
}

/** The connection type for Invoice. */
export type InvoiceConnection = {
  __typename?: 'InvoiceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InvoiceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Invoice>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type InvoiceEdge = {
  __typename?: 'InvoiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Invoice>;
};

export type InvoiceExchangeRate = {
  __typename?: 'InvoiceExchangeRate';
  fromCurrency?: Maybe<Currency>;
  toCurrency?: Maybe<Currency>;
  value?: Maybe<Scalars['Float']>;
};

export type InvoiceItem = Node & {
  __typename?: 'InvoiceItem';
  amountExchanged?: Maybe<Scalars['Boolean']>;
  amountPerUnit?: Maybe<Money>;
  associatedPeriodHumanized?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  currency?: Maybe<Currency>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['Date']>;
  id: Scalars['ID'];
  invoice?: Maybe<Invoice>;
  itemType?: Maybe<InvoiceItemItemType>;
  itemTypeHumanized?: Maybe<Scalars['String']>;
  numUnits?: Maybe<Scalars['Int']>;
  payrollItem?: Maybe<PayrollItem>;
  projectCodesHumanized?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['Date']>;
  subjectName?: Maybe<Scalars['String']>;
  totalAmount?: Maybe<Money>;
};

export enum InvoiceItemItemType {
  /** client request and we waiting for payment */
  BackgroundCheck = 'background_check',
  /** refunding excess payments by the customer */
  CreditNote = 'credit_note',
  /** manually created invoice items */
  Custom = 'custom',
  /** fee for an EOR contract */
  EmployerOfRecordFee = 'employer_of_record_fee',
  /** legacy type for open jobs for landis */
  JobFee = 'job_fee',
  /** fee for a third party integration */
  JobIntegrationActivationFee = 'job_integration_activation_fee',
  /** legacy type for managers fee for landis */
  ManagerFee = 'manager_fee',
  /** fee fom the third party payment system, mostly for exchange. */
  PaymentProcessingFee = 'payment_processing_fee',
  /** for billing a payroll item */
  Payroll = 'payroll',
  /** for invoicing the client when a referral has to be paid and the client has added a referral prize to the job */
  ReferralBoost = 'referral_boost',
  /** fees for usage history */
  TrackingLog = 'tracking_log'
}

/** previews a payment of a given invoice with a given payment method */
export type InvoicePaymentPreview = {
  __typename?: 'InvoicePaymentPreview';
  canPay?: Maybe<Scalars['Boolean']>;
  creditCardFixedFee?: Maybe<Scalars['Float']>;
  creditCardPercentageFee?: Maybe<Scalars['Float']>;
  currency?: Maybe<Currency>;
  currencyCompatible?: Maybe<Scalars['Boolean']>;
  currencyConversionPercentageFee?: Maybe<Scalars['Float']>;
  feeInvoiceItem?: Maybe<InvoiceItem>;
  feesIncluded?: Maybe<Scalars['Boolean']>;
  insufficientFunds?: Maybe<Scalars['Boolean']>;
  invoice?: Maybe<Invoice>;
  maximumLimit?: Maybe<Money>;
  overMaximumLimit?: Maybe<Scalars['Boolean']>;
  paymentMethod?: Maybe<PaymentMethod>;
  totalToPayClient?: Maybe<Money>;
};

/** Autogenerated input type of InvoicePayrollItems */
export type InvoicePayrollItemsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** the recipient of the created invoice(s) */
  invoiceRecipientId?: InputMaybe<Scalars['ID']>;
  /** the items to put in the invoice */
  payrollItemIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of InvoicePayrollItems. */
export type InvoicePayrollItemsPayload = {
  __typename?: 'InvoicePayrollItemsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  invoiceItems?: Maybe<Array<InvoiceItem>>;
  invoices?: Maybe<Array<Invoice>>;
  payrollItems?: Maybe<Array<PayrollItem>>;
};

export enum InvoiceSchedule {
  /** every other week */
  Biweekly = 'biweekly',
  /** once per month */
  Monthly = 'monthly',
  /** once per week */
  Weekly = 'weekly'
}

export enum InvoiceStatus {
  /** the invoice has been issued */
  Active = 'active',
  /** the invoice is still being built and is not complete */
  Draft = 'draft',
  /** the invoice has been voided */
  Void = 'void'
}

/** Autogenerated return type of InvoiceUpdated. */
export type InvoiceUpdatedPayload = {
  __typename?: 'InvoiceUpdatedPayload';
  invoice?: Maybe<Invoice>;
};

export type InvoicesFilters = {
  clientPaymentDueInPast?: InputMaybe<Scalars['Boolean']>;
  /** @deprecated only used in legacy frontend code */
  clientRawId?: InputMaybe<Scalars['Int']>;
  freelancerId?: InputMaybe<Scalars['ID']>;
  fromDueDate?: InputMaybe<Scalars['Date']>;
  invoiceNum?: InputMaybe<Scalars['Int']>;
  order?: InputMaybe<SortOrder>;
  sort?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<InvoiceClientStatus>;
  toDueDate?: InputMaybe<Scalars['Date']>;
  total?: InputMaybe<Scalars['Float']>;
  unpaidByClient?: InputMaybe<Scalars['Boolean']>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type InvoicesSummary = {
  __typename?: 'InvoicesSummary';
  currency: Currency;
  overdueBalance: Money;
  overdueCount: Scalars['Int'];
  unpaidBalance: Money;
  unpaidCount: Scalars['Int'];
};

/** position/job at a company */
export type Job = Node & {
  __typename?: 'Job';
  activeJobIntegrationsNames?: Maybe<Array<Scalars['String']>>;
  allowTextualAnswers: Scalars['Boolean'];
  applications?: Maybe<ApplicationsResults>;
  autoRenew?: Maybe<Scalars['Boolean']>;
  autoSendScreeningRequests?: Maybe<Scalars['Boolean']>;
  automaticallyNotifyCandidates?: Maybe<Scalars['Boolean']>;
  availabilityType?: Maybe<Scalars['String']>;
  candidates?: Maybe<CandidateConnection>;
  candidatesToNotify?: Maybe<Array<CandidateToNotify>>;
  /** for non-remote jobs */
  city?: Maybe<Scalars['String']>;
  clientRate?: Maybe<Money>;
  clientRateCents?: Maybe<Scalars['Int']>;
  /** contract between the current user and the job, if any */
  contract?: Maybe<Contract>;
  contracts?: Maybe<ContractConnection>;
  /** for non-remote jobs. ISO 3166-1 alpha-2 code, lowercase */
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currency?: Maybe<Currency>;
  defaultDistance?: Maybe<Scalars['Float']>;
  description?: Maybe<Scalars['String']>;
  descriptionExperience?: Maybe<Scalars['String']>;
  descriptionResponsibilities?: Maybe<Scalars['String']>;
  expiresAt?: Maybe<Scalars['DateTime']>;
  firm?: Maybe<Firm>;
  freelancerRate?: Maybe<Money>;
  freelancerRateCents?: Maybe<Scalars['Int']>;
  /** @deprecated use job.jobSubtypes */
  freelancerSubtypes: Array<FreelancerSubtype>;
  freelancerType?: Maybe<FreelancerType>;
  /** for non-remote jobs */
  fullAddress?: Maybe<Scalars['String']>;
  hireStats?: Maybe<JobHireStats>;
  hiringManager?: Maybe<User>;
  hiringManagerType?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  internalRecruiter?: Maybe<User>;
  /** ISO 3166-1 alpha-2 codes, lowercase */
  jobCountries: Array<Scalars['String']>;
  jobIntegrations?: Maybe<Array<JobIntegration>>;
  jobSkills: Array<JobSkill>;
  jobSocialIntegrations?: Maybe<Array<Scalars['String']>>;
  jobSubtypes: Array<JobSubtype>;
  locationLatitude?: Maybe<Scalars['Float']>;
  locationLongitude?: Maybe<Scalars['Float']>;
  locationType?: Maybe<JobLocationTypeEnum>;
  margin?: Maybe<Scalars['Float']>;
  markup?: Maybe<Scalars['Float']>;
  minClientRate?: Maybe<Money>;
  minClientRateCents?: Maybe<Scalars['Int']>;
  minFreelancerRate?: Maybe<Money>;
  minFreelancerRateCents?: Maybe<Scalars['Int']>;
  minMarginUsd?: Maybe<Scalars['Float']>;
  numberOfHires?: Maybe<Scalars['Int']>;
  positionTypes: Array<Position>;
  project?: Maybe<Project>;
  projectLengthInMonths?: Maybe<Scalars['Int']>;
  questions?: Maybe<Array<Question>>;
  rateMode?: Maybe<RateMode>;
  rawId?: Maybe<Scalars['Int']>;
  recruiters?: Maybe<Array<User>>;
  referralBounty?: Maybe<Money>;
  /** referral to share this job to others */
  referralFromSelf?: Maybe<Referral>;
  /** for non-remote jobs */
  region?: Maybe<Scalars['String']>;
  requestVideoIntroduction: Scalars['Boolean'];
  requiredExperienceYears?: Maybe<Scalars['Int']>;
  resumeRequiredToApply: Scalars['Boolean'];
  screening?: Maybe<ApplicationsResults>;
  screeningRequestMessageTemplate?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<JobStatus>;
  timezoneIdentifier?: Maybe<Scalars['String']>;
  timezoneRange?: Maybe<Scalars['Int']>;
  timezoneUtcOffset?: Maybe<Scalars['Int']>;
  title: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};


/** position/job at a company */
export type JobApplicationsArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


/** position/job at a company */
export type JobCandidatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<CandidatesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** position/job at a company */
export type JobContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** position/job at a company */
export type JobHireStatsArgs = {
  filters?: InputMaybe<JobHireStatsFilters>;
};


/** position/job at a company */
export type JobScreeningArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};

/** The connection type for Job. */
export type JobConnection = {
  __typename?: 'JobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Job>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type JobEdge = {
  __typename?: 'JobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Job>;
};

export type JobForIntegration = {
  __typename?: 'JobForIntegration';
  /** external ID of the job, coming from the external integration */
  id: Scalars['String'];
  title: Scalars['String'];
};

/** The connection type for JobForIntegration. */
export type JobForIntegrationConnection = {
  __typename?: 'JobForIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobForIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobForIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type JobForIntegrationEdge = {
  __typename?: 'JobForIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JobForIntegration>;
};

export type JobForIntegrationFilters = {
  /** name of the integration to list suitable jobs from */
  integrationName?: InputMaybe<JobIntegrationNameForImportEnum>;
};

export type JobHireStats = {
  __typename?: 'JobHireStats';
  appliedCount?: Maybe<Scalars['Int']>;
  clickedCount?: Maybe<Scalars['Int']>;
  hiredCount?: Maybe<Scalars['Int']>;
  interviewedCount?: Maybe<Scalars['Int']>;
  offeredCount?: Maybe<Scalars['Int']>;
  screenedCount?: Maybe<Scalars['Int']>;
  viewedCount?: Maybe<Scalars['Int']>;
};

export type JobHireStatsFilters = {
  fromDate?: InputMaybe<Scalars['Date']>;
  source?: InputMaybe<Scalars['String']>;
  toDate?: InputMaybe<Scalars['Date']>;
};

export type JobIntegration = Node & {
  __typename?: 'JobIntegration';
  active?: Maybe<Scalars['Boolean']>;
  enabledByUser?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  job?: Maybe<Job>;
  jobIntegrationProvider?: Maybe<JobIntegrationProvider>;
  postingStatus?: Maybe<Scalars['String']>;
  publicationExpires?: Maybe<Scalars['DateTime']>;
  publishedJobUrl?: Maybe<Scalars['String']>;
  /** @deprecated only used in legacy frontend ode */
  rawId?: Maybe<Scalars['Int']>;
};

export enum JobIntegrationNameForImportEnum {
  Greenhouse = 'greenhouse'
}

export type JobIntegrationProvider = {
  __typename?: 'JobIntegrationProvider';
  activationFeeUsd?: Maybe<Scalars['Float']>;
  advertising: Scalars['Boolean'];
  dailyFeeUsd?: Maybe<Scalars['Float']>;
  name: Scalars['String'];
  supportedActions: Array<Scalars['String']>;
};

export enum JobLocationTypeEnum {
  /** contract is active and ongoing */
  Active = 'active',
  Anywhere = 'anywhere',
  /** expired contract has been deleted */
  Deleted = 'deleted',
  /** active/paused contract has ended */
  Expired = 'expired',
  /** member has declined invitation to apply */
  FreelancerNotInterested = 'freelancer_not_interested',
  FullAddress = 'full_address',
  /** interview request has been accepted by the member */
  InterviewAccepted = 'interview_accepted',
  /** interview request has been rejected by the member */
  InterviewRejected = 'interview_rejected',
  /** member has started applying to the job */
  JobApplicationDraft = 'job_application_draft',
  /** member has been invited by the client to apply to the job */
  JobApplicationInvited = 'job_application_invited',
  /** member has sent the job application */
  JobApplicationSent = 'job_application_sent',
  JobTimezone = 'job_timezone',
  /** member has visited the job page */
  JobViewed = 'job_viewed',
  /** an offer has been made via hire pipeline or by inviting an off-platform user */
  OfferMade = 'offer_made',
  /** the member has turned down the offer */
  OfferRejected = 'offer_rejected',
  /** contract is active and ongoing, but timesheet submission and payments are paused */
  Paused = 'paused',
  /** interview has been requested by the client */
  Pending = 'pending',
  /** potential referrer or applicant for the job */
  Potential = 'potential',
  /** during the hiring process, the member has been rejected by the client or an offer has been withdrawn */
  Rejected = 'rejected',
  SpecificCountries = 'specific_countries'
}

export type JobSkill = Node & {
  __typename?: 'JobSkill';
  groupIndex?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** @deprecated use skill.name instead */
  name?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  /** @deprecated use skill.rawId instead */
  rawSkillId?: Maybe<Scalars['Int']>;
  required?: Maybe<Scalars['Boolean']>;
  requiredYears?: Maybe<Scalars['Int']>;
  skill?: Maybe<Skill>;
  /** the current user's matching UserSkill, if any */
  userSkill?: Maybe<UserSkill>;
};

export type JobSkillAttributes = {
  groupIndex?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  rawId?: InputMaybe<Scalars['Int']>;
  rawSkillId?: InputMaybe<Scalars['Int']>;
  required?: InputMaybe<Scalars['Boolean']>;
  requiredYears?: InputMaybe<Scalars['Int']>;
};

export enum JobStatus {
  /** job is closed */
  Closed = 'closed',
  /** job is saved as draft */
  Draft = 'draft',
  /** job is opened */
  Opened = 'opened'
}

export type JobSubtype = Node & {
  __typename?: 'JobSubtype';
  freelancerSubtype?: Maybe<FreelancerSubtype>;
  groupIndex?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  rawId?: Maybe<Scalars['Int']>;
};

export enum JobType {
  /** for freelance jobs, usually paid hourly */
  Freelance = 'freelance',
  /** for permanent jobs, usually paid with a fixed salary */
  Permanent = 'permanent'
}

export type JobView = Job | Referral;

export type JobsFilters = {
  search?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<JobStatus>;
  userId?: InputMaybe<Scalars['ID']>;
};

export type Link = Node & {
  __typename?: 'Link';
  autoLogin: Scalars['Boolean'];
  chatThread?: Maybe<ChatThread>;
  chatUser?: Maybe<User>;
  contract?: Maybe<Contract>;
  emailSubscription?: Maybe<EmailSubscription>;
  firm?: Maybe<Firm>;
  freelancer?: Maybe<User>;
  id: Scalars['ID'];
  job?: Maybe<Job>;
  linkType?: Maybe<LinkTypeEnum>;
  token: Scalars['String'];
  unsubscribeFromAllEmails: Scalars['Boolean'];
  user?: Maybe<User>;
};

export enum LinkTypeEnum {
  Candidate = 'candidate',
  ChatThread = 'chat_thread',
  ChatUser = 'chat_user',
  Login = 'login',
  ProfileFeedback = 'profile_feedback',
  Unsubscribe = 'unsubscribe'
}

/** Autogenerated input type of LinkedinAccessToken */
export type LinkedinAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** not needed if current user is already linked to linkedin */
  code?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of LinkedinAccessToken. */
export type LinkedinAccessTokenPayload = {
  __typename?: 'LinkedinAccessTokenPayload';
  accessToken?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of Login */
export type LoginInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  jobSlug?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
  recaptchaToken?: InputMaybe<Scalars['String']>;
  referer?: InputMaybe<Scalars['String']>;
  refererUrl?: InputMaybe<Scalars['String']>;
  remember?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Login. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of Logout */
export type LogoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of Logout. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  configuration?: Maybe<Configuration>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of MakeOffer */
export type MakeOfferInput = {
  allowHireAccess?: InputMaybe<Scalars['Boolean']>;
  allowManageAccess?: InputMaybe<Scalars['Boolean']>;
  availabilityType?: InputMaybe<Array<Scalars['String']>>;
  bonusClientRate?: InputMaybe<MoneyInput>;
  bonusPeriod?: InputMaybe<ContractBonusPeriod>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRate?: InputMaybe<MoneyInput>;
  currency?: InputMaybe<Scalars['String']>;
  discountCode?: InputMaybe<Scalars['String']>;
  enableTimesheets?: InputMaybe<Scalars['Boolean']>;
  endDate?: InputMaybe<Scalars['Date']>;
  firmId: Scalars['ID'];
  freelancerRecipients?: InputMaybe<Array<InvitationRecipientAttributes>>;
  invitationMessage?: InputMaybe<Scalars['String']>;
  invoiceRecipientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated call updateFirm to change this value */
  invoiceSchedule?: InputMaybe<InvoiceSchedule>;
  isFirmAdmin?: InputMaybe<Scalars['Boolean']>;
  offerNote?: InputMaybe<Scalars['String']>;
  paymentMode?: InputMaybe<PaymentModeEnum>;
  purchaseOrderNumber?: InputMaybe<Scalars['String']>;
  rateMode?: InputMaybe<RateMode>;
  requireApprovalForPayments?: InputMaybe<Scalars['Boolean']>;
  startDate?: InputMaybe<Scalars['Date']>;
};

/** Autogenerated return type of MakeOffer. */
export type MakeOfferPayload = {
  __typename?: 'MakeOfferPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contracts?: Maybe<Array<Contract>>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of MarkChatThreadRead */
export type MarkChatThreadReadInput = {
  chatThreadId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  chatThreadRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of MarkChatThreadRead. */
export type MarkChatThreadReadPayload = {
  __typename?: 'MarkChatThreadReadPayload';
  chatThread?: Maybe<ChatThread>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of Masq */
export type MasqInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used by legacy frontend code */
  userRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of Masq. */
export type MasqPayload = {
  __typename?: 'MasqPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export type Member = {
  __typename?: 'Member';
  contract?: Maybe<Contract>;
  freelancer: User;
  job?: Maybe<Job>;
};

export enum MemberStatusEnum {
  /** contract is active and ongoing */
  Active = 'active',
  /** expired contract has been deleted */
  Deleted = 'deleted',
  /** active/paused contract has ended */
  Expired = 'expired',
  /** member has declined invitation to apply */
  FreelancerNotInterested = 'freelancer_not_interested',
  /** interview request has been accepted by the member */
  InterviewAccepted = 'interview_accepted',
  /** interview request has been rejected by the member */
  InterviewRejected = 'interview_rejected',
  /** member has started applying to the job */
  JobApplicationDraft = 'job_application_draft',
  /** member has been invited by the client to apply to the job */
  JobApplicationInvited = 'job_application_invited',
  /** member has sent the job application */
  JobApplicationSent = 'job_application_sent',
  /** member has visited the job page */
  JobViewed = 'job_viewed',
  /** an offer has been made via hire pipeline or by inviting an off-platform user */
  OfferMade = 'offer_made',
  /** the member has turned down the offer */
  OfferRejected = 'offer_rejected',
  /** contract is active and ongoing, but timesheet submission and payments are paused */
  Paused = 'paused',
  /** interview has been requested by the client */
  Pending = 'pending',
  /** potential referrer or applicant for the job */
  Potential = 'potential',
  /** during the hiring process, the member has been rejected by the client or an offer has been withdrawn */
  Rejected = 'rejected',
  ScreeningIncomplete = 'screening_incomplete'
}

export type MembersFilters = {
  actionableOnly?: InputMaybe<Scalars['Boolean']>;
  contractStatus?: InputMaybe<MemberStatusEnum>;
  hasVideoIntro?: InputMaybe<Scalars['Boolean']>;
  hiddenOnly?: InputMaybe<Scalars['Boolean']>;
  jobId?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<UserStatus>;
  statuses?: InputMaybe<Array<UserStatus>>;
};

/** a Money object */
export type Money = {
  __typename?: 'Money';
  cents: Scalars['Int'];
  currency: Currency;
  exchangedTo?: Maybe<Money>;
  formatted?: Maybe<Scalars['String']>;
  value: Scalars['Float'];
};


/** a Money object */
export type MoneyExchangedToArgs = {
  currency: Scalars['String'];
};


/** a Money object */
export type MoneyFormattedArgs = {
  nullifyWhenZero?: InputMaybe<Scalars['Boolean']>;
};

/** a Money Input object */
export type MoneyInput = {
  currencyCode: Scalars['String'];
  value: Scalars['Float'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** as a member, accept interview or offer */
  acceptContract?: Maybe<AcceptContractPayload>;
  /** accepts contract requests */
  acceptContractRequests?: Maybe<AcceptContractRequestsPayload>;
  /** create a pending job application or submit a job application */
  applyToJob?: Maybe<ApplyToJobPayload>;
  /** approve payroll item by its ID or using the ID of its content */
  approvePayrollItem?: Maybe<ApprovePayrollItemPayload>;
  /** login via an auto-login link */
  autoLoginWithLink?: Maybe<AutoLoginWithLinkPayload>;
  cancelApplication?: Maybe<CancelApplicationPayload>;
  checkoutInvoice?: Maybe<CheckoutInvoicePayload>;
  /** close an open job */
  closeJob?: Maybe<CloseJobPayload>;
  completeReference?: Maybe<CompleteReferencePayload>;
  completeSignature?: Maybe<CompleteSignaturePayload>;
  /** signal S3 upload completion of a video */
  completeVideoUpload?: Maybe<CompleteVideoUploadPayload>;
  confirmEmail?: Maybe<ConfirmEmailPayload>;
  createAnswer?: Maybe<CreateAnswerPayload>;
  /** creates a new API key for the current user */
  createApiKey?: Maybe<CreateApiKeyPayload>;
  createBackgroundCheck?: Maybe<CreateBackgroundCheckPayload>;
  createBlogPost?: Maybe<CreateBlogPostPayload>;
  createChatThread?: Maybe<CreateChatThreadPayload>;
  /** schedule a contract rate change for the future */
  createContractRate?: Maybe<CreateContractRatePayload>;
  createCustomSkill?: Maybe<CreateCustomSkillPayload>;
  createExpense?: Maybe<CreateExpensePayload>;
  createJobIntegration?: Maybe<CreateJobIntegrationPayload>;
  createLink?: Maybe<CreateLinkPayload>;
  createPaymentMethod?: Maybe<CreatePaymentMethodPayload>;
  /** as a member, submit or update a code test */
  createProjectSubmission?: Maybe<CreateProjectSubmissionPayload>;
  createQuestion?: Maybe<CreateQuestionPayload>;
  /** as a member, attach a resume to your profile */
  createResume?: Maybe<CreateResumePayload>;
  createSignableDocuments?: Maybe<CreateSignableDocumentsPayload>;
  createTimesheet?: Maybe<CreateTimesheetPayload>;
  /** create a pending video */
  createVideo?: Maybe<CreateVideoPayload>;
  /** creates a new webhook to send events related to the current user's firm originating from Flexhire to an external service */
  createWebhook?: Maybe<CreateWebhookPayload>;
  /** deactivates a payout method */
  deactivatePayoutMethod?: Maybe<DeactivatePayoutMethodPayload>;
  deleteAnswer?: Maybe<DeleteAnswerPayload>;
  /** deletes an API key for the current user */
  deleteApiKey?: Maybe<DeleteApiKeyPayload>;
  deleteBlogPost?: Maybe<DeleteBlogPostPayload>;
  /** rejects invitation or marks an expired contract as deleted */
  deleteContract?: Maybe<DeleteContractPayload>;
  /** cancel a contract rate change scheduled for the future */
  deleteContractRate?: Maybe<DeleteContractRatePayload>;
  /**
   * deletes an existing payment method for the current user's firm
   * @deprecated Not supported yet. Disabled
   */
  deletePaymentMethod?: Maybe<DeletePaymentMethodPayload>;
  /** as a member, delete a code test submission */
  deleteProjectSubmission?: Maybe<DeleteProjectSubmissionPayload>;
  deleteReference?: Maybe<DeleteReferencePayload>;
  deleteTimesheet?: Maybe<DeleteTimesheetPayload>;
  /** deletes an account */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** delete a video */
  deleteVideo?: Maybe<DeleteVideoPayload>;
  /** deletes an existing webhook */
  deleteWebhook?: Maybe<DeleteWebhookPayload>;
  /** terminate an active or paused contract */
  expireContract?: Maybe<ExpireContractPayload>;
  /** generate and fetch stripe express dashboard login url */
  fetchStripeLoginUrl?: Maybe<FetchStripeLoginUrlPayload>;
  forgotPassword?: Maybe<ForgotPasswordPayload>;
  /** grants a one-time bonus for a contract */
  grantBonus?: Maybe<GrantBonusPayload>;
  inviteFriend?: Maybe<InviteFriendPayload>;
  /** invoice the specified payroll items now, instead of waiting until the auto-schedule does it */
  invoicePayrollItems?: Maybe<InvoicePayrollItemsPayload>;
  linkedinAccessToken?: Maybe<LinkedinAccessTokenPayload>;
  login?: Maybe<LoginPayload>;
  logout?: Maybe<LogoutPayload>;
  /** make an offer to an existing flexhire user or invite an off-platform person */
  makeOffer?: Maybe<MakeOfferPayload>;
  markChatThreadRead?: Maybe<MarkChatThreadReadPayload>;
  /** become another user */
  masq?: Maybe<MasqPayload>;
  oauthLogin?: Maybe<OauthLoginPayload>;
  /** pause an active contract */
  pauseContract?: Maybe<PauseContractPayload>;
  /** query a submitted payroll item */
  queryPayrollItem?: Maybe<QueryPayrollItemPayload>;
  refreshPaymentStatus?: Maybe<RefreshPaymentStatusPayload>;
  refreshPayoutMethodRequirements?: Maybe<RefreshPayoutMethodRequirementsPayload>;
  registerFrontendVersion?: Maybe<RegisterFrontendVersionPayload>;
  /** rejects a contract as a member */
  rejectContract?: Maybe<RejectContractPayload>;
  /** rejects contract requests */
  rejectContractRequests?: Maybe<RejectContractRequestsPayload>;
  /** rejects a freelancer on the hire pipeline, marking them as not suited to be hired for the job */
  rejectFreelancer?: Maybe<RejectFreelancerPayload>;
  rejectPayrollItem?: Maybe<RejectPayrollItemPayload>;
  /** @deprecated experimental. Not working yet */
  removeSignableDocument?: Maybe<RemoveSignableDocumentPayload>;
  /** request an interview to an applicant */
  requestInterview?: Maybe<RequestInterviewPayload>;
  requestReference?: Maybe<RequestReferencePayload>;
  /** resends the invitation email for the given invitation contract */
  resendInvitationEmail?: Maybe<ResendInvitationEmailPayload>;
  resetPassword?: Maybe<ResetPasswordPayload>;
  /** resumes a paused contract */
  resumeContract?: Maybe<ResumeContractPayload>;
  /** send a chat message. If sent without an account, the user is logged into a 'guest' type account automatically */
  sendChatMessage?: Maybe<SendChatMessagePayload>;
  sendConfirmationEmail?: Maybe<SendConfirmationEmailPayload>;
  /** adds feedback for the client's team on a potential hire */
  sendContractRating?: Maybe<SendContractRatingPayload>;
  /** send questions or a code test to a potential hire */
  sendContractRequests?: Maybe<SendContractRequestsPayload>;
  sendJobOpportunity?: Maybe<SendJobOpportunityPayload>;
  /** as a member, set up a crypto wallet address to get paid */
  setupCryptoWallet?: Maybe<SetupCryptoWalletPayload>;
  setupPaymentMethod?: Maybe<SetupPaymentMethodPayload>;
  /** as a member, set up a payoneer account to get paid */
  setupPayoneer?: Maybe<SetupPayoneerPayload>;
  /** as a member, set up a stripe connect account to get paid */
  setupStripeConnectedAccount?: Maybe<SetupStripeConnectedAccountPayload>;
  /** as a member, set up a Wise recipient to get paid */
  setupWise?: Maybe<SetupWisePayload>;
  signup?: Maybe<SignupPayload>;
  /** skip a suggested candidate for a job, to replace his slot with another candidate */
  skipCandidate?: Maybe<SkipCandidatePayload>;
  startApplication?: Maybe<StartApplicationPayload>;
  submitApplication?: Maybe<SubmitApplicationPayload>;
  submitPayoutMethodRequirements?: Maybe<SubmitPayoutMethodRequirementsPayload>;
  submitPayrollItem?: Maybe<SubmitPayrollItemPayload>;
  submitProfile?: Maybe<SubmitProfilePayload>;
  submitVerification?: Maybe<SubmitVerificationPayload>;
  /** toggle bookmarked status for members on the hire pipeline */
  toggleBookmarkFreelancer?: Maybe<ToggleBookmarkFreelancerPayload>;
  twitterAccessToken?: Maybe<TwitterAccessTokenPayload>;
  twitterRequestToken?: Maybe<TwitterRequestTokenPayload>;
  /** unapprove payroll item by its ID, before it is invoiced */
  unapprovePayrollItem?: Maybe<UnapprovePayrollItemPayload>;
  /** undo any masq operations for this session */
  unmasq?: Maybe<UnmasqPayload>;
  /** unsubscribe current user from email subscription */
  unsubscribe?: Maybe<UnsubscribePayload>;
  updateBlogPost?: Maybe<UpdateBlogPostPayload>;
  /** update existing bonus data */
  updateBonus?: Maybe<UpdateBonusPayload>;
  updateChatThread?: Maybe<UpdateChatThreadPayload>;
  /** update a running contract */
  updateContract?: Maybe<UpdateContractPayload>;
  /** change a contract rate change scheduled for the future */
  updateContractRate?: Maybe<UpdateContractRatePayload>;
  /** update multiple contracts */
  updateContracts?: Maybe<UpdateContractsPayload>;
  updateEmailSubscription?: Maybe<UpdateEmailSubscriptionPayload>;
  /** update a firm */
  updateFirm?: Maybe<UpdateFirmPayload>;
  /** update details of a job */
  updateJobDetails?: Maybe<UpdateJobDetailsPayload>;
  /** update screening configuration for a job */
  updateJobScreening?: Maybe<UpdateJobScreeningPayload>;
  /** update sourcing configuration for a job */
  updateJobSourcing?: Maybe<UpdateJobSourcingPayload>;
  /** as a member, submit or update a code test */
  updateProjectSubmission?: Maybe<UpdateProjectSubmissionPayload>;
  updateSalary?: Maybe<UpdateSalaryPayload>;
  updateTimesheet?: Maybe<UpdateTimesheetPayload>;
  updateUnsubscribedFromAllEmails?: Maybe<UpdateUnsubscribedFromAllEmailsPayload>;
  /** update a user */
  updateUser?: Maybe<UpdateUserPayload>;
  /** update settings of a video */
  updateVideo?: Maybe<UpdateVideoPayload>;
  updateWebhook?: Maybe<UpdateWebhookPayload>;
};


export type MutationAcceptContractArgs = {
  input: AcceptContractInput;
};


export type MutationAcceptContractRequestsArgs = {
  input: AcceptContractRequestsInput;
};


export type MutationApplyToJobArgs = {
  input: ApplyToJobInput;
};


export type MutationApprovePayrollItemArgs = {
  input: ApprovePayrollItemInput;
};


export type MutationAutoLoginWithLinkArgs = {
  input: AutoLoginWithLinkInput;
};


export type MutationCancelApplicationArgs = {
  input: CancelApplicationInput;
};


export type MutationCheckoutInvoiceArgs = {
  input: CheckoutInvoiceInput;
};


export type MutationCloseJobArgs = {
  input: CloseJobInput;
};


export type MutationCompleteReferenceArgs = {
  input: CompleteReferenceInput;
};


export type MutationCompleteSignatureArgs = {
  input: CompleteSignatureInput;
};


export type MutationCompleteVideoUploadArgs = {
  input: CompleteVideoUploadInput;
};


export type MutationConfirmEmailArgs = {
  input: ConfirmEmailInput;
};


export type MutationCreateAnswerArgs = {
  input: CreateAnswerInput;
};


export type MutationCreateApiKeyArgs = {
  input: CreateApiKeyInput;
};


export type MutationCreateBackgroundCheckArgs = {
  input: CreateBackgroundCheckInput;
};


export type MutationCreateBlogPostArgs = {
  input: CreateBlogPostInput;
};


export type MutationCreateChatThreadArgs = {
  input: CreateChatThreadInput;
};


export type MutationCreateContractRateArgs = {
  input: CreateContractRateInput;
};


export type MutationCreateCustomSkillArgs = {
  input: CreateCustomSkillInput;
};


export type MutationCreateExpenseArgs = {
  input: CreateExpenseInput;
};


export type MutationCreateJobIntegrationArgs = {
  input: CreateJobIntegrationInput;
};


export type MutationCreateLinkArgs = {
  input: CreateLinkInput;
};


export type MutationCreatePaymentMethodArgs = {
  input: CreatePaymentMethodInput;
};


export type MutationCreateProjectSubmissionArgs = {
  input: CreateProjectSubmissionInput;
};


export type MutationCreateQuestionArgs = {
  input: CreateQuestionInput;
};


export type MutationCreateResumeArgs = {
  input: CreateResumeInput;
};


export type MutationCreateSignableDocumentsArgs = {
  input: CreateSignableDocumentsInput;
};


export type MutationCreateTimesheetArgs = {
  input: CreateTimesheetInput;
};


export type MutationCreateVideoArgs = {
  input: CreateVideoInput;
};


export type MutationCreateWebhookArgs = {
  input: CreateWebhookInput;
};


export type MutationDeactivatePayoutMethodArgs = {
  input: DeactivatePayoutMethodInput;
};


export type MutationDeleteAnswerArgs = {
  input: DeleteAnswerInput;
};


export type MutationDeleteApiKeyArgs = {
  input: DeleteApiKeyInput;
};


export type MutationDeleteBlogPostArgs = {
  input: DeleteBlogPostInput;
};


export type MutationDeleteContractArgs = {
  input: DeleteContractInput;
};


export type MutationDeleteContractRateArgs = {
  input: DeleteContractRateInput;
};


export type MutationDeletePaymentMethodArgs = {
  input: DeletePaymentMethodInput;
};


export type MutationDeleteProjectSubmissionArgs = {
  input: DeleteProjectSubmissionInput;
};


export type MutationDeleteReferenceArgs = {
  input: DeleteReferenceInput;
};


export type MutationDeleteTimesheetArgs = {
  input: DeleteTimesheetInput;
};


export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


export type MutationDeleteVideoArgs = {
  input: DeleteVideoInput;
};


export type MutationDeleteWebhookArgs = {
  input: DeleteWebhookInput;
};


export type MutationExpireContractArgs = {
  input: ExpireContractInput;
};


export type MutationFetchStripeLoginUrlArgs = {
  input: FetchStripeLoginUrlInput;
};


export type MutationForgotPasswordArgs = {
  input: ForgotPasswordInput;
};


export type MutationGrantBonusArgs = {
  input: GrantBonusInput;
};


export type MutationInviteFriendArgs = {
  input: InviteFriendInput;
};


export type MutationInvoicePayrollItemsArgs = {
  input: InvoicePayrollItemsInput;
};


export type MutationLinkedinAccessTokenArgs = {
  input: LinkedinAccessTokenInput;
};


export type MutationLoginArgs = {
  input: LoginInput;
};


export type MutationLogoutArgs = {
  input: LogoutInput;
};


export type MutationMakeOfferArgs = {
  input: MakeOfferInput;
};


export type MutationMarkChatThreadReadArgs = {
  input: MarkChatThreadReadInput;
};


export type MutationMasqArgs = {
  input: MasqInput;
};


export type MutationOauthLoginArgs = {
  input: OauthLoginInput;
};


export type MutationPauseContractArgs = {
  input: PauseContractInput;
};


export type MutationQueryPayrollItemArgs = {
  input: QueryPayrollItemInput;
};


export type MutationRefreshPaymentStatusArgs = {
  input: RefreshPaymentStatusInput;
};


export type MutationRefreshPayoutMethodRequirementsArgs = {
  input: RefreshPayoutMethodRequirementsInput;
};


export type MutationRegisterFrontendVersionArgs = {
  input: RegisterFrontendVersionInput;
};


export type MutationRejectContractArgs = {
  input: RejectContractInput;
};


export type MutationRejectContractRequestsArgs = {
  input: RejectContractRequestsInput;
};


export type MutationRejectFreelancerArgs = {
  input: RejectFreelancerInput;
};


export type MutationRejectPayrollItemArgs = {
  input: RejectPayrollItemInput;
};


export type MutationRemoveSignableDocumentArgs = {
  input: RemoveSignableDocumentInput;
};


export type MutationRequestInterviewArgs = {
  input: RequestInterviewInput;
};


export type MutationRequestReferenceArgs = {
  input: RequestReferenceInput;
};


export type MutationResendInvitationEmailArgs = {
  input: ResendInvitationEmailInput;
};


export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


export type MutationResumeContractArgs = {
  input: ResumeContractInput;
};


export type MutationSendChatMessageArgs = {
  input: SendChatMessageInput;
};


export type MutationSendConfirmationEmailArgs = {
  input: SendConfirmationEmailInput;
};


export type MutationSendContractRatingArgs = {
  input: SendContractRatingInput;
};


export type MutationSendContractRequestsArgs = {
  input: SendContractRequestsInput;
};


export type MutationSendJobOpportunityArgs = {
  input: SendJobOpportunityInput;
};


export type MutationSetupCryptoWalletArgs = {
  input: SetupCryptoWalletInput;
};


export type MutationSetupPaymentMethodArgs = {
  input: SetupPaymentMethodInput;
};


export type MutationSetupPayoneerArgs = {
  input: SetupPayoneerInput;
};


export type MutationSetupStripeConnectedAccountArgs = {
  input: SetupStripeConnectedAccountInput;
};


export type MutationSetupWiseArgs = {
  input: SetupWiseInput;
};


export type MutationSignupArgs = {
  input: SignupInput;
};


export type MutationSkipCandidateArgs = {
  input: SkipCandidateInput;
};


export type MutationStartApplicationArgs = {
  input: StartApplicationInput;
};


export type MutationSubmitApplicationArgs = {
  input: SubmitApplicationInput;
};


export type MutationSubmitPayoutMethodRequirementsArgs = {
  input: SubmitPayoutMethodRequirementsInput;
};


export type MutationSubmitPayrollItemArgs = {
  input: SubmitPayrollItemInput;
};


export type MutationSubmitProfileArgs = {
  input: SubmitProfileInput;
};


export type MutationSubmitVerificationArgs = {
  input: SubmitVerificationInput;
};


export type MutationToggleBookmarkFreelancerArgs = {
  input: ToggleBookmarkFreelancerInput;
};


export type MutationTwitterAccessTokenArgs = {
  input: TwitterAccessTokenInput;
};


export type MutationTwitterRequestTokenArgs = {
  input: TwitterRequestTokenInput;
};


export type MutationUnapprovePayrollItemArgs = {
  input: UnapprovePayrollItemInput;
};


export type MutationUnmasqArgs = {
  input: UnmasqInput;
};


export type MutationUnsubscribeArgs = {
  input: UnsubscribeInput;
};


export type MutationUpdateBlogPostArgs = {
  input: UpdateBlogPostInput;
};


export type MutationUpdateBonusArgs = {
  input: UpdateBonusInput;
};


export type MutationUpdateChatThreadArgs = {
  input: UpdateChatThreadInput;
};


export type MutationUpdateContractArgs = {
  input: UpdateContractInput;
};


export type MutationUpdateContractRateArgs = {
  input: UpdateContractRateInput;
};


export type MutationUpdateContractsArgs = {
  input: UpdateContractsInput;
};


export type MutationUpdateEmailSubscriptionArgs = {
  input: UpdateEmailSubscriptionInput;
};


export type MutationUpdateFirmArgs = {
  input: UpdateFirmInput;
};


export type MutationUpdateJobDetailsArgs = {
  input: UpdateJobDetailsInput;
};


export type MutationUpdateJobScreeningArgs = {
  input: UpdateJobScreeningInput;
};


export type MutationUpdateJobSourcingArgs = {
  input: UpdateJobSourcingInput;
};


export type MutationUpdateProjectSubmissionArgs = {
  input: UpdateProjectSubmissionInput;
};


export type MutationUpdateSalaryArgs = {
  input: UpdateSalaryInput;
};


export type MutationUpdateTimesheetArgs = {
  input: UpdateTimesheetInput;
};


export type MutationUpdateUnsubscribedFromAllEmailsArgs = {
  input: UpdateUnsubscribedFromAllEmailsInput;
};


export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


export type MutationUpdateVideoArgs = {
  input: UpdateVideoInput;
};


export type MutationUpdateWebhookArgs = {
  input: UpdateWebhookInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** Autogenerated input type of OauthLogin */
export type OauthLoginInput = {
  accessToken: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  providerName: OauthProviderName;
};

/** Autogenerated return type of OauthLogin. */
export type OauthLoginPayload = {
  __typename?: 'OauthLoginPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export enum OauthProviderName {
  /** unsupported at the moment */
  Github = 'github',
  Linkedin = 'linkedin'
}

/** a key/value pair that acts as an option for a select field */
export type Option = {
  __typename?: 'Option';
  label: Scalars['String'];
  value: Scalars['String'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** a key/value pair */
export type PairInput = {
  key: Scalars['String'];
  value?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of PauseContract */
export type PauseContractInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
};

/** Autogenerated return type of PauseContract. */
export type PauseContractPayload = {
  __typename?: 'PauseContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

export type Paycheck = Node & {
  __typename?: 'Paycheck';
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  itemNum?: Maybe<Scalars['Int']>;
  paidOutAt?: Maybe<Scalars['DateTime']>;
  payrollItems?: Maybe<Array<PayrollItem>>;
  status?: Maybe<PaycheckStatusEnum>;
  totalToPayFreelancer?: Maybe<Money>;
};

/** The connection type for Paycheck. */
export type PaycheckConnection = {
  __typename?: 'PaycheckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PaycheckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Paycheck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type PaycheckEdge = {
  __typename?: 'PaycheckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Paycheck>;
};

export enum PaycheckStatusEnum {
  /** payout to member failed */
  Failed = 'failed',
  /** payout to member successful */
  Paid = 'paid',
  /** payout to member is draft / not final */
  Pending = 'pending',
  /** payout to member is prepared */
  Ready = 'ready'
}

export type PaychecksFilters = {
  status: PaycheckStatusEnum;
};

export type PaymentMethod = Node & {
  __typename?: 'PaymentMethod';
  achAccountNumber?: Maybe<Scalars['String']>;
  achRoutingNumber?: Maybe<Scalars['String']>;
  amountAvailable?: Maybe<Money>;
  bic?: Maybe<Scalars['String']>;
  cardholderName?: Maybe<Scalars['String']>;
  currency?: Maybe<Currency>;
  customerId?: Maybe<Scalars['String']>;
  default: Scalars['Boolean'];
  expMonth?: Maybe<Scalars['Int']>;
  expYear?: Maybe<Scalars['Int']>;
  firm?: Maybe<Firm>;
  iban?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  institutionName?: Maybe<Scalars['String']>;
  isManualTransfer?: Maybe<Scalars['Boolean']>;
  mask?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  paymentMethodType?: Maybe<PaymentMethodTypeLiteral>;
  rawId?: Maybe<Scalars['Int']>;
  swiftCode?: Maybe<Scalars['String']>;
  token?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export enum PaymentMethodTypeLiteral {
  AchCreditTransfer = 'ach_credit_transfer',
  BankTransfer = 'bank_transfer',
  Card = 'card',
  PlaidLink = 'plaid_link',
  SepaDebit = 'sepa_debit'
}

export enum PaymentModeEnum {
  /** work reports will have a rate and the salary is based on them */
  PayWorkReports = 'pay_work_reports',
  /** payroll is disabled (only use this for filtering) */
  PaymentsDisabled = 'payments_disabled',
  /** the salary is a fixed monthly amount */
  Salary = 'salary'
}

export type Payout = Node & {
  __typename?: 'Payout';
  amount?: Maybe<Money>;
  bonus?: Maybe<Bonus>;
  contract?: Maybe<Contract>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  itemNum?: Maybe<Scalars['Int']>;
  paycheck?: Maybe<Paycheck>;
  status?: Maybe<PayoutStatusEnum>;
  timesheet?: Maybe<Timesheet>;
  userPaymentId?: Maybe<Scalars['String']>;
};

/** The connection type for Payout. */
export type PayoutConnection = {
  __typename?: 'PayoutConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PayoutEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Payout>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type PayoutEdge = {
  __typename?: 'PayoutEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Payout>;
};

export type PayoutMethod = Node & {
  __typename?: 'PayoutMethod';
  accountId?: Maybe<Scalars['String']>;
  /** some payout methods have a specific currency associated to them */
  currency?: Maybe<Currency>;
  id: Scalars['ID'];
  isDefault?: Maybe<Scalars['Boolean']>;
  payoutMethodType: PayoutMethodTypeEnum;
  requirementGroups?: Maybe<Array<RequirementGroup>>;
  setupUrl?: Maybe<Scalars['String']>;
  status: PayoutMethodStatusEnum;
};

export enum PayoutMethodStatusEnum {
  Active = 'active',
  Failed = 'failed',
  Pending = 'pending'
}

export enum PayoutMethodTypeEnum {
  Aggregated = 'aggregated',
  CryptoWallet = 'crypto_wallet',
  OffPlatform = 'off_platform',
  Payoneer = 'payoneer',
  StripeConnect = 'stripe_connect',
  Wise = 'wise'
}

export enum PayoutMode {
  /** automatic payouts happen on a fixed schedule regardless of client invoice payment */
  SkipWaitingForInvoicePayment = 'skip_waiting_for_invoice_payment',
  /** automatic payouts will happen after client invoice payment has completed */
  WaitForInvoicePayment = 'wait_for_invoice_payment'
}

export enum PayoutStatusEnum {
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing',
  Successful = 'successful'
}

export type PayoutsFilters = {
  contractStatuses?: InputMaybe<Array<ContractStatus>>;
  endDate?: InputMaybe<Scalars['Date']>;
  startDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<PayoutStatusEnum>;
};

export type PayoutsStats = {
  __typename?: 'PayoutsStats';
  count: Scalars['Int'];
  currency: Currency;
  totalPaid: Money;
  totalPending: Money;
};

/** income/cost summary for time period */
export type PayrollBreakdown = {
  __typename?: 'PayrollBreakdown';
  breakdownItems: Array<PayrollBreakdownItem>;
  freelancers: Array<User>;
};

export enum PayrollBreakdownGroupByEnum {
  Day = 'day',
  Month = 'month',
  Week = 'week'
}

/** summarized income/cost for time period */
export type PayrollBreakdownItem = {
  __typename?: 'PayrollBreakdownItem';
  date: Scalars['Date'];
  total: Money;
};

export type PayrollItem = Node & {
  __typename?: 'PayrollItem';
  approvedAt?: Maybe<Scalars['DateTime']>;
  approver?: Maybe<User>;
  assumedClientPaymentCompletionAt?: Maybe<Scalars['DateTime']>;
  assumedClientPaymentInitiationAt?: Maybe<Scalars['DateTime']>;
  assumedInvoiceDate?: Maybe<Scalars['DateTime']>;
  assumedInvoiceDueDate?: Maybe<Scalars['DateTime']>;
  assumedPayoutCompletionAt?: Maybe<Scalars['DateTime']>;
  /** @deprecated use assumedPayoutCompletionAt instead */
  assumedPayoutDueDate?: Maybe<Scalars['DateTime']>;
  assumedPayoutInitiationAt?: Maybe<Scalars['DateTime']>;
  autoApprove?: Maybe<Scalars['Boolean']>;
  autoApproved?: Maybe<Scalars['Boolean']>;
  bonus?: Maybe<Bonus>;
  clientComments?: Maybe<Scalars['String']>;
  /** @deprecated use pipelineStatus instead */
  clientStatus?: Maybe<PayrollItemClientStatus>;
  contract?: Maybe<Contract>;
  contractRates?: Maybe<Array<ContractRate>>;
  currency?: Maybe<Currency>;
  endDate?: Maybe<Scalars['Date']>;
  expense?: Maybe<Expense>;
  firm?: Maybe<Firm>;
  /** @deprecated use pipelineStatus instead */
  freelancerStatus?: Maybe<PayrollItemFreelancerStatus>;
  id: Scalars['ID'];
  invoice?: Maybe<Invoice>;
  invoiceItem?: Maybe<InvoiceItem>;
  itemNum?: Maybe<Scalars['Int']>;
  itemType?: Maybe<PayrollItemType>;
  itemTypeHumanized?: Maybe<Scalars['String']>;
  manageable?: Maybe<Scalars['Boolean']>;
  manuallyInvoiceable?: Maybe<Scalars['Boolean']>;
  paycheck?: Maybe<Paycheck>;
  pipelineStatus?: Maybe<PayrollItemPipelineStatus>;
  rawId?: Maybe<Scalars['Int']>;
  salary?: Maybe<Salary>;
  startDate?: Maybe<Scalars['Date']>;
  status?: Maybe<PayrollItemStatus>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timesheet?: Maybe<Timesheet>;
  totalToPayClient?: Maybe<Money>;
  totalToPayFreelancer?: Maybe<Money>;
  unapprovable?: Maybe<Scalars['Boolean']>;
};


export type PayrollItemContractRatesArgs = {
  filters?: InputMaybe<ContractRatesFilters>;
};

export enum PayrollItemClientStatus {
  /** approved by the client */
  Approved = 'approved',
  /** queried by the client */
  ClientQuery = 'client_query',
  /**
   * invoiced to the customer
   * @deprecated use pipelineStatus instead
   */
  Invoiced = 'invoiced',
  /**
   * paid out to the freelancer
   * @deprecated use pipelineStatus instead
   */
  Paid = 'paid',
  /**
   * processing customer payment
   * @deprecated use pipelineStatus instead
   */
  PaymentProcessing = 'payment_processing',
  /**
   * payout to the freelancer has failed
   * @deprecated use pipelineStatus instead
   */
  PayoutFailed = 'payout_failed',
  /** not yet submitted */
  Pending = 'pending',
  /**
   * submitted and waiting for manual approval
   * @deprecated use pipelineStatus instead
   */
  PendingApproval = 'pending_approval',
  /** rejected by the client */
  Rejected = 'rejected',
  /** submitted, waiting for client approval or auto approval */
  Submitted = 'submitted',
  /**
   * submitted and waiting for auto approval
   * @deprecated use pipelineStatus instead
   */
  SubmittedAutoApproval = 'submitted_auto_approval'
}

/** The connection type for PayrollItem. */
export type PayrollItemConnection = {
  __typename?: 'PayrollItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PayrollItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PayrollItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type PayrollItemEdge = {
  __typename?: 'PayrollItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PayrollItem>;
};

export enum PayrollItemFreelancerStatus {
  /** approved by the client */
  Approved = 'approved',
  /**
   * paid by the client, not paid to the freelancer yet
   * @deprecated use pipelineStatus instead
   */
  ClientPaid = 'client_paid',
  /**
   * client has initiated payment, which has not completed yet
   * @deprecated use pipelineStatus instead
   */
  ClientPaymentProcessing = 'client_payment_processing',
  /** queried by the client */
  ClientQuery = 'client_query',
  /**
   * the timesheet has been invoiced, but the client has not initiated payment yet
   * @deprecated use pipelineStatus instead
   */
  Invoiced = 'invoiced',
  /**
   * paid out to the freelancer
   * @deprecated use pipelineStatus instead
   */
  Paid = 'paid',
  /**
   * payout to the freelancer has failed
   * @deprecated use pipelineStatus instead
   */
  PayoutFailed = 'payout_failed',
  /** not yet submitted */
  Pending = 'pending',
  /** rejected by the client */
  Rejected = 'rejected',
  /** submitted, waiting for client approval or auto approval */
  Submitted = 'submitted'
}

export enum PayrollItemPipelineStatus {
  /** approved by the client */
  Approved = 'approved',
  /** processing payment from the customer to Flexhire */
  ClientPaymentProcessing = 'client_payment_processing',
  /** queried by the client */
  ClientQuery = 'client_query',
  /** invoiced to the customer */
  Invoiced = 'invoiced',
  /** processing payment from Flexhire to the member */
  MemberPaymentProcessing = 'member_payment_processing',
  /** paid out to the member */
  PaidOut = 'paid_out',
  /** payout to the member has failed */
  PayoutFailed = 'payout_failed',
  /** not yet submitted */
  Pending = 'pending',
  /** rejected by the client */
  Rejected = 'rejected',
  /** submitted, waiting for client approval or auto approval */
  Submitted = 'submitted'
}

export enum PayrollItemStatus {
  /** approved by the client */
  Approved = 'approved',
  /** queried by the client */
  ClientQuery = 'client_query',
  /** not yet submitted */
  Pending = 'pending',
  /** rejected by the client */
  Rejected = 'rejected',
  /** submitted, waiting for client approval or auto approval */
  Submitted = 'submitted'
}

export enum PayrollItemType {
  /** contains one bonus */
  Bonus = 'bonus',
  /** contains one expense */
  Expense = 'expense',
  /** contains a periodic fixed salary */
  Salary = 'salary',
  /** contains one timesheet (work report) */
  Timesheet = 'timesheet'
}

export type PayrollItemsFilters = {
  approvalType?: InputMaybe<ApprovalTypeEnum>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated use pipelineStatus instead */
  clientStatus?: InputMaybe<PayrollItemClientStatus>;
  endDate?: InputMaybe<Scalars['Date']>;
  /** @deprecated use pipelineStatus instead */
  freelancerStatus?: InputMaybe<PayrollItemFreelancerStatus>;
  invoiceNum?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  pipelineStatus?: InputMaybe<PayrollItemPipelineStatus>;
  startDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<PayrollItemStatus>;
  type?: InputMaybe<PayrollItemType>;
};

export type PayrollStats = {
  __typename?: 'PayrollStats';
  currency: Currency;
  totalPaid: Money;
  totalPending: Money;
  totalTimePaidInMinutes: Scalars['Float'];
};

export enum Position {
  /** for freelance jobs, usually paid hourly */
  Freelancer = 'freelancer',
  /** for permanent jobs, usually paid with a fixed salary */
  Permanent = 'permanent'
}

export type Profile = Node & {
  __typename?: 'Profile';
  addressRecipient?: Maybe<Scalars['String']>;
  allowScreening?: Maybe<Scalars['Boolean']>;
  availability?: Maybe<ProfileAvailabilityEnum>;
  availabilityType?: Maybe<Array<ProfileAvailabilityTypeLiteral>>;
  availableAt?: Maybe<Scalars['DateTime']>;
  canWorkInTheUs?: Maybe<Scalars['Boolean']>;
  city?: Maybe<Scalars['String']>;
  cityRecipient?: Maybe<Scalars['String']>;
  clientRate?: Maybe<Money>;
  /** ISO 3166-1 alpha-2 code, lowercase */
  country?: Maybe<Scalars['String']>;
  countryRecipient?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currency?: Maybe<Currency>;
  freelancerRate?: Maybe<Money>;
  freelancerSubtypes?: Maybe<Array<FreelancerSubtype>>;
  freelancerType?: Maybe<FreelancerType>;
  fullAddress?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  jobTypes: Array<JobType>;
  lastMessagedAt?: Maybe<Scalars['DateTime']>;
  locationBounds0?: Maybe<Scalars['Float']>;
  locationBounds1?: Maybe<Scalars['Float']>;
  locationBounds2?: Maybe<Scalars['Float']>;
  locationBounds3?: Maybe<Scalars['Float']>;
  locationBounds4?: Maybe<Scalars['Float']>;
  locationLatitude?: Maybe<Scalars['Float']>;
  locationLongitude?: Maybe<Scalars['Float']>;
  managedTeamSize?: Maybe<Scalars['String']>;
  openToOpportunities?: Maybe<Scalars['Boolean']>;
  rateMode?: Maybe<RateMode>;
  rawId?: Maybe<Scalars['Int']>;
  region?: Maybe<Scalars['String']>;
  screeningFeedback?: Maybe<Scalars['String']>;
  screeningRequiresProject?: Maybe<Scalars['Boolean']>;
  slug?: Maybe<Scalars['String']>;
  stateRecipient?: Maybe<Scalars['String']>;
  taxFirm?: Maybe<Scalars['String']>;
  taxId?: Maybe<Scalars['String']>;
  textIntroduction?: Maybe<Scalars['String']>;
  totalExperience?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  urlBlog?: Maybe<Scalars['String']>;
  urlDribbble?: Maybe<Scalars['String']>;
  urlGithub?: Maybe<Scalars['String']>;
  urlLinkedin?: Maybe<Scalars['String']>;
  usCitizen?: Maybe<Scalars['Boolean']>;
  visibility?: Maybe<ProfileVisibilityEnum>;
  zip?: Maybe<Scalars['String']>;
};

export type ProfileAttributes = {
  addressRecipient?: InputMaybe<Scalars['String']>;
  availability?: InputMaybe<ProfileAvailabilityEnum>;
  availabilityType?: InputMaybe<Array<Scalars['String']>>;
  availableAt?: InputMaybe<Scalars['Date']>;
  canWorkInTheUs?: InputMaybe<Scalars['Boolean']>;
  cityRecipient?: InputMaybe<Scalars['String']>;
  countryRecipient?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  freelancerRate?: InputMaybe<Scalars['Float']>;
  freelancerTypeId?: InputMaybe<Scalars['Int']>;
  jobTypes?: InputMaybe<Array<Scalars['String']>>;
  locationBounds0?: InputMaybe<Scalars['Float']>;
  locationBounds1?: InputMaybe<Scalars['Float']>;
  locationBounds2?: InputMaybe<Scalars['Float']>;
  locationBounds3?: InputMaybe<Scalars['Float']>;
  locationLatitude?: InputMaybe<Scalars['Float']>;
  locationLongitude?: InputMaybe<Scalars['Float']>;
  managedTeamSize?: InputMaybe<Scalars['String']>;
  openToOpportunities?: InputMaybe<Scalars['Boolean']>;
  rateMode?: InputMaybe<RateMode>;
  stateRecipient?: InputMaybe<Scalars['String']>;
  taxFirm?: InputMaybe<Scalars['String']>;
  taxId?: InputMaybe<Scalars['String']>;
  textIntroduction?: InputMaybe<Scalars['String']>;
  totalExperience?: InputMaybe<Scalars['Int']>;
  urlBlog?: InputMaybe<Scalars['String']>;
  urlDribbble?: InputMaybe<Scalars['String']>;
  urlGithub?: InputMaybe<Scalars['String']>;
  urlLinkedin?: InputMaybe<Scalars['String']>;
  usCitizen?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<ProfileVisibilityEnum>;
  zip?: InputMaybe<Scalars['String']>;
};

export enum ProfileAvailabilityEnum {
  AvailableNow = 'available_now',
  AvailableSoon = 'available_soon',
  NotAvailable = 'not_available'
}

export enum ProfileAvailabilityTypeLiteral {
  FullTime = 'full_time',
  PartTime = 'part_time'
}

export enum ProfileVisibilityEnum {
  VisibilityClients = 'visibility_clients',
  VisibilityPrivate = 'visibility_private',
  VisibilityPublic = 'visibility_public'
}

export type Project = Node & {
  __typename?: 'Project';
  custom?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  rawId?: Maybe<Scalars['Int']>;
  screening?: Maybe<Scalars['Boolean']>;
  status?: Maybe<Scalars['String']>;
  submission?: Maybe<ProjectSubmission>;
  title?: Maybe<Scalars['String']>;
};

export type ProjectAttributes = {
  description?: InputMaybe<Scalars['String']>;
  rawId?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
};

/** The connection type for Project. */
export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

export type ProjectSubmission = Node & {
  __typename?: 'ProjectSubmission';
  contractRequests?: Maybe<Array<ContractRequest>>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  project?: Maybe<Project>;
  rawId?: Maybe<Scalars['Int']>;
  screenshotUrl?: Maybe<Scalars['String']>;
  status?: Maybe<ProjectSubmissionStatusEnum>;
  url?: Maybe<Scalars['String']>;
};

export enum ProjectSubmissionStatusEnum {
  Private = 'private',
  Public = 'public'
}

/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type Query = {
  __typename?: 'Query';
  /** show all available billing plans */
  billingPlans?: Maybe<Array<BillingPlan>>;
  blogCategories?: Maybe<BlogCategoryConnection>;
  blogCategory?: Maybe<BlogCategory>;
  blogPost?: Maybe<BlogPost>;
  blogPosts?: Maybe<BlogPostConnection>;
  blogSubcategory?: Maybe<BlogCategory>;
  /** @deprecated only used in legacy frontend code */
  chatThread?: Maybe<ChatThread>;
  /** configuration values for the frontend. User specific */
  configuration?: Maybe<Configuration>;
  /** load a contract: use either id, rawId, a combination of jobSlug and freelancerSlug, or freelancerEmail */
  contract?: Maybe<Contract>;
  /**
   * preview changes resulting from updating a contract for active/paused contracts
   * and offer made contracts. Most useful for previewing rate changes
   */
  contractPreview?: Maybe<ContractPreview>;
  /** all contracts visible by the current user will be included */
  contracts: ContractConnection;
  costBreakdown?: Maybe<PayrollBreakdown>;
  currencies?: Maybe<Array<Currency>>;
  /** resolves to the currently logged in user */
  currentUser?: Maybe<User>;
  /** get email subscriptions for a logged out user using an unsubscribe token */
  emailSubscriptions?: Maybe<Array<EmailSubscription>>;
  featuredFreelancers?: Maybe<Array<User>>;
  featuredQuestionsCategories?: Maybe<Array<QuestionCategory>>;
  firm?: Maybe<Firm>;
  /** all firms visible by the current user will be included */
  firms: FirmConnection;
  /** @deprecated only used for legacy Frontend code */
  freelancerSubtype?: Maybe<FreelancerSubtype>;
  /** shows all freelancer subtypes (specializations) on the platform */
  freelancerSubtypes?: Maybe<Array<FreelancerSubtype>>;
  freelancerType?: Maybe<FreelancerType>;
  /** shows all freelancer types (industries) on the platform */
  freelancerTypes?: Maybe<Array<FreelancerType>>;
  institutes?: Maybe<InstituteConnection>;
  invoice?: Maybe<Invoice>;
  job?: Maybe<JobView>;
  /** list of possible integrations for jobs on Flexhire */
  jobIntegrationProviders?: Maybe<Array<JobIntegrationProvider>>;
  /**
   * all jobs visible by the current user will be included
   * @deprecated use firm.jobs or user.jobs
   */
  jobs?: Maybe<JobConnection>;
  /**
   * load a Link's data using its token. Note that if the link has auto-login, you
   * will need to use the autoLoginWithLink mutation to do it
   */
  link?: Maybe<Link>;
  /** list all members of the platform. Only used in backoffice tools */
  members?: Maybe<UserConnection>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes?: Maybe<Array<Node>>;
  /** optionally load a node. if null is passed, null will be returned */
  optionalNode?: Maybe<Node>;
  /** all code tests visible to the current user */
  projects?: Maybe<ProjectConnection>;
  publicChatContacts?: Maybe<UserConnection>;
  questionCategory?: Maybe<QuestionCategory>;
  questions?: Maybe<QuestionConnection>;
  reference?: Maybe<Reference>;
  /** warning: experimental. Can be used to load a resource by slug. Could be a User, Firm or Job */
  resource?: Maybe<Resource>;
  salaryPreview?: Maybe<SalaryPreview>;
  /** @deprecated only used in legacy frontend code */
  skill?: Maybe<Skill>;
  /** all selectable/usable skills on the platform */
  skills?: Maybe<Array<Skill>>;
  /** @deprecated only used by legacy frontend code */
  timesheet?: Maybe<Timesheet>;
  /** check if a user is unsubscribed from all emails using an unsubscribe token */
  unsubscribedFromAllEmails?: Maybe<Scalars['Boolean']>;
  urlValidity?: Maybe<ValidationResult>;
  /** load user on the platform. Must be visible to the current user */
  user?: Maybe<User>;
  /** admin only field to search across all users */
  users?: Maybe<UserConnection>;
  /** @deprecated only used by legacy frontend code */
  video?: Maybe<Video>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryBlogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryBlogCategoryArgs = {
  slug: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryBlogPostArgs = {
  slug: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryBlogPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryBlogSubcategoryArgs = {
  slug: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryChatThreadArgs = {
  rawId?: InputMaybe<Scalars['Int']>;
  userRawId?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryContractArgs = {
  freelancerEmail?: InputMaybe<Scalars['String']>;
  freelancerSlug?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  jobSlug?: InputMaybe<Scalars['String']>;
  rawId?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryContractPreviewArgs = {
  input: ContractPreviewAttributes;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryCostBreakdownArgs = {
  clientId?: InputMaybe<Scalars['ID']>;
  freelancerId?: InputMaybe<Scalars['ID']>;
  groupBy: PayrollBreakdownGroupByEnum;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryCurrenciesArgs = {
  allowContracts?: InputMaybe<Scalars['Boolean']>;
  allowInvoices?: InputMaybe<Scalars['Boolean']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryEmailSubscriptionsArgs = {
  token: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryFirmArgs = {
  slug?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryFirmsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryFreelancerSubtypeArgs = {
  rawIdOrSlug?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryFreelancerTypeArgs = {
  id?: InputMaybe<Scalars['ID']>;
  rawId?: InputMaybe<Scalars['Int']>;
  rawIdOrSlug?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryInstitutesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryInvoiceArgs = {
  rawId?: InputMaybe<Scalars['Int']>;
  token?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryJobArgs = {
  rawId?: InputMaybe<Scalars['Int']>;
  ref?: InputMaybe<Scalars['String']>;
  referrer?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  firmSlug?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<JobStatus>;
  userId?: InputMaybe<Scalars['ID']>;
  userRawId?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryLinkArgs = {
  token: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<MembersFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryNodeArgs = {
  id: Scalars['ID'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryOptionalNodeArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  screening?: InputMaybe<Scalars['Boolean']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryPublicChatContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryQuestionCategoryArgs = {
  slug: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryQuestionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<QuestionsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryReferenceArgs = {
  token: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryResourceArgs = {
  ref?: InputMaybe<Scalars['String']>;
  referrer?: InputMaybe<Scalars['String']>;
  slug: Scalars['String'];
  subslug?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QuerySalaryPreviewArgs = {
  input: SalaryPreviewAttributes;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QuerySkillArgs = {
  slug?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QuerySkillsArgs = {
  featured?: InputMaybe<Scalars['Boolean']>;
  freelancerTypeRawId?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryTimesheetArgs = {
  rawId?: InputMaybe<Scalars['Int']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryUnsubscribedFromAllEmailsArgs = {
  token: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryUrlValidityArgs = {
  url: Scalars['String'];
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryUserArgs = {
  id?: InputMaybe<Scalars['ID']>;
  rawId?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** Flexhire API - refer to https://flexhire.com/developer for more information */
export type QueryVideoArgs = {
  rawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of QueryPayrollItem */
export type QueryPayrollItemInput = {
  clientComments: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payrollItemId: Scalars['ID'];
};

/** Autogenerated return type of QueryPayrollItem. */
export type QueryPayrollItemPayload = {
  __typename?: 'QueryPayrollItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payrollItem?: Maybe<PayrollItem>;
};

export type Question = Node & {
  __typename?: 'Question';
  answersCount?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  freelancerSubtypes?: Maybe<Array<FreelancerSubtype>>;
  freelancerTypes?: Maybe<Array<FreelancerType>>;
  id: Scalars['ID'];
  jobsCount?: Maybe<Scalars['Int']>;
  maxDuration?: Maybe<Scalars['Int']>;
  rawId?: Maybe<Scalars['Int']>;
  skills?: Maybe<Array<Skill>>;
  status?: Maybe<QuestionStatusEnum>;
  tags?: Maybe<Array<Tag>>;
  /** the textual answer submitted by the current user, if any */
  textualAnswer?: Maybe<Answer>;
  title?: Maybe<Scalars['String']>;
  /** the video answer submitted by the current user, if any */
  videoAnswer?: Maybe<Answer>;
};

export type QuestionAttributes = {
  description?: InputMaybe<Scalars['String']>;
  maxDuration?: InputMaybe<Scalars['Int']>;
  rawId?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

/** a category for featured questions */
export type QuestionCategory = FreelancerSubtype | FreelancerType | Skill | Tag;

/** The connection type for Question. */
export type QuestionConnection = {
  __typename?: 'QuestionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<QuestionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Question>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type QuestionEdge = {
  __typename?: 'QuestionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Question>;
};

export enum QuestionStatusEnum {
  Private = 'private',
  Public = 'public',
  Submitted = 'submitted'
}

export type QuestionsFilters = {
  /** if true, only return featured questions */
  featured?: InputMaybe<Scalars['Boolean']>;
  /** @deprecated only used in legacy frontend code */
  freelancerSubtypeRawIds?: InputMaybe<Array<Scalars['Int']>>;
  /** @deprecated only used in legacy frontend code */
  freelancerTypeRawIds?: InputMaybe<Array<Scalars['Int']>>;
  /** @deprecated only used in legacy frontend code */
  page?: InputMaybe<Scalars['Int']>;
  /** @deprecated only used in legacy frontend code */
  perPage?: InputMaybe<Scalars['Int']>;
  /** @deprecated only used in legacy frontend code */
  skillRawIds?: InputMaybe<Array<Scalars['Int']>>;
  /** search by title */
  title?: InputMaybe<Scalars['String']>;
};

export enum RateMode {
  Day = 'day',
  Hour = 'hour',
  Month = 'month',
  Week = 'week',
  Year = 'year'
}

export type Recipient = ChatBot | User;

export type Reference = Node & {
  __typename?: 'Reference';
  comments?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  otherRelation?: Maybe<Scalars['String']>;
  ratingExpert?: Maybe<Scalars['Int']>;
  ratingOverall?: Maybe<Scalars['Int']>;
  ratingProfessional?: Maybe<Scalars['Int']>;
  /** @deprecated only used in legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  relation?: Maybe<ReferenceRelationEnum>;
  status?: Maybe<ReferenceStatusEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};

export enum ReferenceRelationEnum {
  Classmate = 'classmate',
  Client = 'client',
  Coworker = 'coworker',
  Friend = 'friend',
  Other = 'other'
}

export enum ReferenceStatusEnum {
  Completed = 'completed',
  Pending = 'pending'
}

export type Referral = Node & {
  __typename?: 'Referral';
  id: Scalars['ID'];
  job?: Maybe<Job>;
  token?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RefreshPaymentStatus */
export type RefreshPaymentStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paymentIntentId: Scalars['String'];
};

/** Autogenerated return type of RefreshPaymentStatus. */
export type RefreshPaymentStatusPayload = {
  __typename?: 'RefreshPaymentStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  invoice?: Maybe<Invoice>;
};

/** Autogenerated input type of RefreshPayoutMethodRequirements */
export type RefreshPayoutMethodRequirementsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payoutMethodId: Scalars['ID'];
  requirementValues: Array<PairInput>;
  type: Scalars['String'];
};

/** Autogenerated return type of RefreshPayoutMethodRequirements. */
export type RefreshPayoutMethodRequirementsPayload = {
  __typename?: 'RefreshPayoutMethodRequirementsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  requirementGroups?: Maybe<Array<RequirementGroup>>;
};

/** Autogenerated input type of RegisterFrontendVersion */
export type RegisterFrontendVersionInput = {
  buildId: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  key: Scalars['String'];
};

/** Autogenerated return type of RegisterFrontendVersion. */
export type RegisterFrontendVersionPayload = {
  __typename?: 'RegisterFrontendVersionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of RejectContract */
export type RejectContractInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  contractRawId?: InputMaybe<Scalars['Int']>;
  freelancerFeedback?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RejectContract. */
export type RejectContractPayload = {
  __typename?: 'RejectContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of RejectContractRequests */
export type RejectContractRequestsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  contractRawId?: InputMaybe<Scalars['Int']>;
  freelancerFeedback?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RejectContractRequests. */
export type RejectContractRequestsPayload = {
  __typename?: 'RejectContractRequestsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of RejectFreelancer */
export type RejectFreelancerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRejectionComments?: InputMaybe<Scalars['String']>;
  clientRejectionMessage?: InputMaybe<Scalars['String']>;
  clientRejectionReason?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
};

/** Autogenerated return type of RejectFreelancer. */
export type RejectFreelancerPayload = {
  __typename?: 'RejectFreelancerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of RejectPayrollItem */
export type RejectPayrollItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payrollItemId: Scalars['ID'];
};

/** Autogenerated return type of RejectPayrollItem. */
export type RejectPayrollItemPayload = {
  __typename?: 'RejectPayrollItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payrollItem?: Maybe<PayrollItem>;
};

/** Autogenerated input type of RemoveSignableDocument */
export type RemoveSignableDocumentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  signableDocumentId: Scalars['ID'];
};

/** Autogenerated return type of RemoveSignableDocument. */
export type RemoveSignableDocumentPayload = {
  __typename?: 'RemoveSignableDocumentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
  signableDocument?: Maybe<SignableDocument>;
};

/** Autogenerated input type of RequestInterview */
export type RequestInterviewInput = {
  calendlyUrl?: InputMaybe<Scalars['String']>;
  clientAgreesTerms: Scalars['Boolean'];
  clientId: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
  interviewDate1?: InputMaybe<Scalars['DateTime']>;
  interviewDate2?: InputMaybe<Scalars['DateTime']>;
  interviewDate3?: InputMaybe<Scalars['DateTime']>;
  interviewNote?: InputMaybe<Scalars['String']>;
  interviewSchedulingMethod: Scalars['String'];
};

/** Autogenerated return type of RequestInterview. */
export type RequestInterviewPayload = {
  __typename?: 'RequestInterviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of RequestReference */
export type RequestReferenceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  message?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

/** Autogenerated return type of RequestReference. */
export type RequestReferencePayload = {
  __typename?: 'RequestReferencePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  reference?: Maybe<Reference>;
};

/** a required field to fill in */
export type Requirement = {
  __typename?: 'Requirement';
  defaultValue?: Maybe<Scalars['String']>;
  example?: Maybe<Scalars['String']>;
  /** unique key/identifier of this field */
  key: Scalars['String'];
  maxLength?: Maybe<Scalars['Int']>;
  minLength?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  options?: Maybe<Array<Option>>;
  refreshOnChange: Scalars['Boolean'];
  required: Scalars['Boolean'];
  type: RequirementTypeEnum;
  validationAsync?: Maybe<Scalars['String']>;
  validationRegexp?: Maybe<Scalars['String']>;
};

/** a section of required fields to fill in */
export type RequirementGroup = {
  __typename?: 'RequirementGroup';
  description: Scalars['String'];
  requirements: Array<Requirement>;
  title: Scalars['String'];
  type: Scalars['String'];
};

export enum RequirementTypeEnum {
  Date = 'date',
  Radio = 'radio',
  Select = 'select',
  Text = 'text'
}

/** Autogenerated input type of ResendInvitationEmail */
export type ResendInvitationEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
};

/** Autogenerated return type of ResendInvitationEmail. */
export type ResendInvitationEmailPayload = {
  __typename?: 'ResendInvitationEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of ResetPassword */
export type ResetPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  handOff?: InputMaybe<Scalars['Boolean']>;
  password: Scalars['String'];
  passwordConfirmation: Scalars['String'];
  token: Scalars['String'];
};

/** Autogenerated return type of ResetPassword. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export type Resource = Firm | Job | User;

export type Resume = Node & {
  __typename?: 'Resume';
  /** true if the resume is to be imported to the associated user's profile */
  copyToProfile?: Maybe<Scalars['Boolean']>;
  filename?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** @deprecated use importTimeoutAt instead */
  importTimedOut?: Maybe<Scalars['Boolean']>;
  importTimeoutAt?: Maybe<Scalars['DateTime']>;
  mimetype?: Maybe<Scalars['String']>;
  status?: Maybe<ResumeStatusEnum>;
  /** true if the import has been completed and the result is deemed positive */
  success?: Maybe<Scalars['Boolean']>;
  url?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of ResumeContract */
export type ResumeContractInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
};

/** Autogenerated return type of ResumeContract. */
export type ResumeContractPayload = {
  __typename?: 'ResumeContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated return type of ResumeProcessingFinished. */
export type ResumeProcessingFinishedPayload = {
  __typename?: 'ResumeProcessingFinishedPayload';
  resume?: Maybe<Resume>;
};

export enum ResumeStatusEnum {
  Processed = 'processed',
  Processing = 'processing',
  ProcessingFailed = 'processing_failed',
  ProcessingQueued = 'processing_queued',
  Unprocessed = 'unprocessed'
}

export type SalariesFilters = {
  amount?: InputMaybe<Scalars['Int']>;
  approvalType?: InputMaybe<ApprovalTypeEnum>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated use pipelineStatus instead */
  clientStatus?: InputMaybe<PayrollItemClientStatus>;
  contractStatuses?: InputMaybe<Array<ContractStatus>>;
  date?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  /** @deprecated use pipelineStatus instead */
  freelancerStatus?: InputMaybe<PayrollItemFreelancerStatus>;
  invoiceNum?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  pipelineStatus?: InputMaybe<PayrollItemPipelineStatus>;
  startDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<PayrollItemStatus>;
};

export type Salary = Node & {
  __typename?: 'Salary';
  contract?: Maybe<Contract>;
  currency?: Maybe<Currency>;
  customAmount?: Maybe<Scalars['Boolean']>;
  daysOff?: Maybe<Array<Scalars['Date']>>;
  editDescription?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['Date']>;
  id: Scalars['ID'];
  payrollItem?: Maybe<PayrollItem>;
  startDate?: Maybe<Scalars['Date']>;
  totalToPayClient?: Maybe<Money>;
  totalToPayFreelancer?: Maybe<Money>;
  workedDays?: Maybe<Array<Scalars['Date']>>;
  workingDays?: Maybe<Array<Scalars['Date']>>;
};

/** The connection type for Salary. */
export type SalaryConnection = {
  __typename?: 'SalaryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SalaryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Salary>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type SalaryEdge = {
  __typename?: 'SalaryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Salary>;
};

export type SalaryPreview = {
  __typename?: 'SalaryPreview';
  daysOff?: Maybe<Array<Scalars['Date']>>;
  totalToPayClient?: Maybe<Money>;
  totalToPayFreelancer?: Maybe<Money>;
};

export type SalaryPreviewAttributes = {
  customAmount: Scalars['Boolean'];
  daysOff: Array<Scalars['Date']>;
  salaryId: Scalars['ID'];
  totalToPayClient?: InputMaybe<Scalars['Float']>;
  totalToPayFreelancer?: InputMaybe<Scalars['Float']>;
};

/** Autogenerated return type of SeenOnline. */
export type SeenOnlinePayload = {
  __typename?: 'SeenOnlinePayload';
  user?: Maybe<User>;
};

/** Autogenerated input type of SendChatMessage */
export type SendChatMessageInput = {
  chatBotId?: InputMaybe<Scalars['ID']>;
  chatThreadId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  chatThreadRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  message: Scalars['String'];
  recipientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  recipientRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of SendChatMessage. */
export type SendChatMessagePayload = {
  __typename?: 'SendChatMessagePayload';
  chatMessage?: Maybe<ChatMessage>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of SendConfirmationEmail */
export type SendConfirmationEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SendConfirmationEmail. */
export type SendConfirmationEmailPayload = {
  __typename?: 'SendConfirmationEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of SendContractRating */
export type SendContractRatingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
  description: Scalars['String'];
  ratingPositive: Scalars['Boolean'];
  status: Scalars['String'];
};

/** Autogenerated return type of SendContractRating. */
export type SendContractRatingPayload = {
  __typename?: 'SendContractRatingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contractFeedback?: Maybe<ContractFeedback>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of SendContractRequests */
export type SendContractRequestsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
  messageTemplate?: InputMaybe<Scalars['String']>;
  projectDescription?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['Int']>;
  projectTitle?: InputMaybe<Scalars['String']>;
  questionsIds?: InputMaybe<Array<Scalars['Int']>>;
  questionsTitles?: InputMaybe<Array<Scalars['String']>>;
  videoIntroduction?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of SendContractRequests. */
export type SendContractRequestsPayload = {
  __typename?: 'SendContractRequestsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of SendJobOpportunity */
export type SendJobOpportunityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** @deprecated only used in legacy frontend code */
  freelancerRawIdOrSlug?: InputMaybe<Scalars['String']>;
  jobId?: InputMaybe<Scalars['ID']>;
  userId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of SendJobOpportunity. */
export type SendJobOpportunityPayload = {
  __typename?: 'SendJobOpportunityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of SetupCryptoWallet */
export type SetupCryptoWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  walletAddress?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SetupCryptoWallet. */
export type SetupCryptoWalletPayload = {
  __typename?: 'SetupCryptoWalletPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
  payoutMethod?: Maybe<PayoutMethod>;
};

/** Autogenerated input type of SetupPaymentMethod */
export type SetupPaymentMethodInput = {
  callbackUrl?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  paymentMethodType: PaymentMethodTypeLiteral;
};

/** Autogenerated return type of SetupPaymentMethod. */
export type SetupPaymentMethodPayload = {
  __typename?: 'SetupPaymentMethodPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  sessionId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SetupPayoneer */
export type SetupPayoneerInput = {
  alreadyHaveAnAccount?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SetupPayoneer. */
export type SetupPayoneerPayload = {
  __typename?: 'SetupPayoneerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
  /** @deprecated unused */
  message?: Maybe<Scalars['String']>;
  payoutMethod?: Maybe<PayoutMethod>;
};

/** Autogenerated input type of SetupStripeConnectedAccount */
export type SetupStripeConnectedAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SetupStripeConnectedAccount. */
export type SetupStripeConnectedAccountPayload = {
  __typename?: 'SetupStripeConnectedAccountPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
  payoutMethod?: Maybe<PayoutMethod>;
};

/** Autogenerated input type of SetupWise */
export type SetupWiseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** optionally pass this to load parameters such as the currency from it */
  contractId?: InputMaybe<Scalars['ID']>;
  /** optionally explicitly specify the currency that the funds will be sent in */
  currency?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SetupWise. */
export type SetupWisePayload = {
  __typename?: 'SetupWisePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<User>;
  errors?: Maybe<Array<Error>>;
  payoutMethod?: Maybe<PayoutMethod>;
};

export type SignableDocument = Node & {
  __typename?: 'SignableDocument';
  contracts?: Maybe<Array<Contract>>;
  id: Scalars['ID'];
  signatures?: Maybe<Array<Signature>>;
  title: Scalars['String'];
  url: Scalars['String'];
  user?: Maybe<User>;
};

/** a document file attached to a contract */
export type SignableDocumentAttributes = {
  title: Scalars['String'];
  url: Scalars['String'];
};

export type Signature = Node & {
  __typename?: 'Signature';
  documentUrl?: Maybe<Scalars['String']>;
  embedSignUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  signableDocument?: Maybe<SignableDocument>;
  signatureRequestId?: Maybe<Scalars['String']>;
  status: SignatureStatusEnum;
  user?: Maybe<User>;
};

export enum SignatureStatusEnum {
  Declined = 'declined',
  Pending = 'pending',
  Requested = 'requested',
  Signed = 'signed'
}

/** Autogenerated input type of Signup */
export type SignupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** if passed, a new firm with this name will be created and the user will be set as owner */
  companyName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  firstName: Scalars['String'];
  jobSlug?: InputMaybe<Scalars['String']>;
  lastName: Scalars['String'];
  logoUrl?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
  passwordConfirmation: Scalars['String'];
  phone?: InputMaybe<Scalars['String']>;
  recaptchaToken?: InputMaybe<Scalars['String']>;
  ref?: InputMaybe<Scalars['String']>;
  referer?: InputMaybe<Scalars['String']>;
  refererUrl?: InputMaybe<Scalars['String']>;
  remember?: InputMaybe<Scalars['Boolean']>;
  resumeUrl?: InputMaybe<Scalars['String']>;
  termsOfServiceApproved?: InputMaybe<Scalars['Boolean']>;
  website?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of Signup. */
export type SignupPayload = {
  __typename?: 'SignupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export type Skill = Node & {
  __typename?: 'Skill';
  /** true if the skill is user created and not made fully public yet */
  custom?: Maybe<Scalars['Boolean']>;
  /** if this skill was user created, this is the user that created it */
  customUser?: Maybe<User>;
  featuredFreelancerTypes?: Maybe<Array<FreelancerType>>;
  featuredFreelancers?: Maybe<Array<User>>;
  featuredQuestions?: Maybe<Array<Question>>;
  freelancerTypes?: Maybe<Array<FreelancerType>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
};

export type SkillFilter = {
  groupIndex?: InputMaybe<Scalars['Int']>;
  id: Scalars['Int'];
  name?: InputMaybe<Scalars['String']>;
  requiredYears?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of SkipCandidate */
export type SkipCandidateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  freelancerId: Scalars['ID'];
  jobId: Scalars['ID'];
  reason?: InputMaybe<Scalars['String']>;
  system?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of SkipCandidate. */
export type SkipCandidatePayload = {
  __typename?: 'SkipCandidatePayload';
  candidate: Candidate;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

export enum SortOrder {
  /** sort ascending (default) */
  Asc = 'asc',
  /** sort descending */
  Desc = 'desc'
}

/** Autogenerated input type of StartApplication */
export type StartApplicationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of StartApplication. */
export type StartApplicationPayload = {
  __typename?: 'StartApplicationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export type StripeCharge = Node & {
  __typename?: 'StripeCharge';
  id: Scalars['ID'];
  invoice?: Maybe<Invoice>;
  paymentMethod?: Maybe<PaymentMethod>;
  status: StripeChargeStatusEnum;
  user?: Maybe<User>;
};

export enum StripeChargeStatusEnum {
  Failed = 'failed',
  Paid = 'paid',
  Pending = 'pending',
  Processing = 'processing'
}

/** Autogenerated input type of SubmitApplication */
export type SubmitApplicationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SubmitApplication. */
export type SubmitApplicationPayload = {
  __typename?: 'SubmitApplicationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of SubmitPayoutMethodRequirements */
export type SubmitPayoutMethodRequirementsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payoutMethodId: Scalars['ID'];
  requirementValues: Array<PairInput>;
  /** the type of the requirement group being submitted */
  type: Scalars['String'];
};

/** Autogenerated return type of SubmitPayoutMethodRequirements. */
export type SubmitPayoutMethodRequirementsPayload = {
  __typename?: 'SubmitPayoutMethodRequirementsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payoutMethod?: Maybe<PayoutMethod>;
};

/** Autogenerated input type of SubmitPayrollItem */
export type SubmitPayrollItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payrollItemId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of SubmitPayrollItem. */
export type SubmitPayrollItemPayload = {
  __typename?: 'SubmitPayrollItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payrollItem?: Maybe<PayrollItem>;
};

/** Autogenerated input type of SubmitProfile */
export type SubmitProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SubmitProfile. */
export type SubmitProfilePayload = {
  __typename?: 'SubmitProfilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of SubmitVerification */
export type SubmitVerificationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SubmitVerification. */
export type SubmitVerificationPayload = {
  __typename?: 'SubmitVerificationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

export type Subscription = {
  __typename?: 'Subscription';
  chatMessageReceived: ChatMessageReceivedPayload;
  chatThreadUpdated: ChatThreadUpdatedPayload;
  contractUpdated: ContractUpdatedPayload;
  firmUpdated: FirmUpdatedPayload;
  frontendVersionDeployed: FrontendVersionDeployedPayload;
  invoiceUpdated: InvoiceUpdatedPayload;
  resumeProcessingFinished: ResumeProcessingFinishedPayload;
  seenOnline: SeenOnlinePayload;
  userUpdated: UserUpdatedPayload;
  videoUpdated: VideoUpdatedPayload;
};


export type SubscriptionChatMessageReceivedArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionChatThreadUpdatedArgs = {
  chatThreadId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionContractUpdatedArgs = {
  contractId: Scalars['ID'];
};


export type SubscriptionFirmUpdatedArgs = {
  firmId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionInvoiceUpdatedArgs = {
  invoiceId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionResumeProcessingFinishedArgs = {
  userId?: InputMaybe<Scalars['ID']>;
  userRawId?: InputMaybe<Scalars['Int']>;
};


export type SubscriptionSeenOnlineArgs = {
  userId?: InputMaybe<Scalars['ID']>;
  userRawId?: InputMaybe<Scalars['Int']>;
};


export type SubscriptionUserUpdatedArgs = {
  userId?: InputMaybe<Scalars['ID']>;
};


export type SubscriptionVideoUpdatedArgs = {
  videoId?: InputMaybe<Scalars['ID']>;
  videoRawId?: InputMaybe<Scalars['Int']>;
};

/** identifies which type of email subscription it is and what kind of emails will be received if it's active */
export enum SubscriptionName {
  /** includes reminder emails about completing the profile */
  FreelancerIncomplete = 'freelancer_incomplete',
  /** emails the user when a matching opened job is found */
  JobOpportunity = 'job_opportunity',
  /** emails the user when a job matching their industry and location is found, so they can refer people and win a prize */
  ReferralOpportunity = 'referral_opportunity',
  /** emails the user periodically if they have an active contract with timesheets, to remind them to submit them */
  TimesheetReminders = 'timesheet_reminders'
}

export type Tag = Node & {
  __typename?: 'Tag';
  featuredQuestions?: Maybe<Array<Question>>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
};

export type TagFilter = {
  id: Scalars['Int'];
};

export type TimelineEntry = Node & {
  __typename?: 'TimelineEntry';
  /** dateEnd set to null means the entry is active */
  dateEnd?: Maybe<Scalars['Date']>;
  dateStart?: Maybe<Scalars['Date']>;
  description?: Maybe<Scalars['String']>;
  entryType?: Maybe<TimelineEntryTypeEnum>;
  id: Scalars['ID'];
  /** institute that this record is associated with */
  institute?: Maybe<Institute>;
  place?: Maybe<Scalars['String']>;
  /** @deprecated only used in legacy frontend code */
  rawId?: Maybe<Scalars['Int']>;
  /** these are the skills that are associated with this entry */
  skills?: Maybe<Array<Skill>>;
  title?: Maybe<Scalars['String']>;
};

export type TimelineEntryAttributes = {
  dateEnd?: InputMaybe<Scalars['Date']>;
  dateStart?: InputMaybe<Scalars['Date']>;
  description?: InputMaybe<Scalars['String']>;
  entryType?: InputMaybe<TimelineEntryTypeEnum>;
  id?: InputMaybe<Scalars['ID']>;
  instituteId?: InputMaybe<Scalars['ID']>;
  place?: InputMaybe<Scalars['String']>;
  skillsRawIds?: InputMaybe<Array<Scalars['Int']>>;
  title?: InputMaybe<Scalars['String']>;
};

export enum TimelineEntryTypeEnum {
  Education = 'education',
  Work = 'work'
}

export type Timesheet = Node & {
  __typename?: 'Timesheet';
  clientRatingFeedbackContinue?: Maybe<Scalars['String']>;
  clientRatingFeedbackStart?: Maybe<Scalars['String']>;
  clientRatingFeedbackStop?: Maybe<Scalars['String']>;
  clientRatingScore?: Maybe<Scalars['Int']>;
  contract?: Maybe<Contract>;
  createdAt?: Maybe<Scalars['DateTime']>;
  currency?: Maybe<Currency>;
  editable?: Maybe<Scalars['Boolean']>;
  endDate?: Maybe<Scalars['Date']>;
  expenses?: Maybe<Array<Expense>>;
  id: Scalars['ID'];
  invoice?: Maybe<Invoice>;
  payrollItem?: Maybe<PayrollItem>;
  projectCodes?: Maybe<Array<Scalars['String']>>;
  rawId?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['Date']>;
  timesheetEntries?: Maybe<Array<TimesheetEntry>>;
  totalCapitalExpenditure?: Maybe<Money>;
  totalExpenses?: Maybe<Money>;
  totalHours?: Maybe<Scalars['Int']>;
  totalMinutes?: Maybe<Scalars['Int']>;
  totalOperatingExpenditure?: Maybe<Money>;
  totalToPayClient?: Maybe<Money>;
  totalToPayFreelancer?: Maybe<Money>;
  totalUnassignedExpenditure?: Maybe<Money>;
};

/** The connection type for Timesheet. */
export type TimesheetConnection = {
  __typename?: 'TimesheetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimesheetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Timesheet>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type TimesheetEdge = {
  __typename?: 'TimesheetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Timesheet>;
};

export type TimesheetEntry = Node & {
  __typename?: 'TimesheetEntry';
  currency?: Maybe<Currency>;
  description?: Maybe<Scalars['String']>;
  endTime?: Maybe<Scalars['DateTime']>;
  expenseType?: Maybe<ExpenseTypeEnum>;
  hourlyClientRate?: Maybe<Money>;
  hourlyFreelancerRate?: Maybe<Money>;
  id: Scalars['ID'];
  projectCode?: Maybe<Scalars['String']>;
  rawId?: Maybe<Scalars['Int']>;
  startTime?: Maybe<Scalars['DateTime']>;
  timesheet?: Maybe<Timesheet>;
  totalToPayClient?: Maybe<Money>;
  totalToPayFreelancer?: Maybe<Money>;
};

export type TimesheetEntryAttributes = {
  description?: InputMaybe<Scalars['String']>;
  endTime?: InputMaybe<Scalars['DateTime']>;
  expenseType?: InputMaybe<ExpenseTypeEnum>;
  projectCode?: InputMaybe<Scalars['String']>;
  startTime?: InputMaybe<Scalars['DateTime']>;
};

export type TimesheetsFilters = {
  approvalType?: InputMaybe<ApprovalTypeEnum>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** @deprecated used only by legacy frontend code */
  clientRawId?: InputMaybe<Scalars['Int']>;
  /** @deprecated use pipelineStatus instead */
  clientStatus?: InputMaybe<PayrollItemClientStatus>;
  contractStatuses?: InputMaybe<Array<ContractStatus>>;
  /** @deprecated use pipelineStatus instead */
  freelancerStatus?: InputMaybe<PayrollItemFreelancerStatus>;
  fromDate?: InputMaybe<Scalars['Date']>;
  invoiceNum?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  notInvoiced?: InputMaybe<Scalars['Boolean']>;
  order?: InputMaybe<SortOrder>;
  pipelineStatus?: InputMaybe<PayrollItemPipelineStatus>;
  sortBy?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<PayrollItemStatus>;
  tags?: InputMaybe<Array<TagFilter>>;
  toDate?: InputMaybe<Scalars['Date']>;
};

/** Autogenerated input type of ToggleBookmarkFreelancer */
export type ToggleBookmarkFreelancerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  contractId: Scalars['ID'];
};

/** Autogenerated return type of ToggleBookmarkFreelancer. */
export type ToggleBookmarkFreelancerPayload = {
  __typename?: 'ToggleBookmarkFreelancerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of TwitterAccessToken */
export type TwitterAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  oauthVerifier?: InputMaybe<Scalars['String']>;
  requestToken?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of TwitterAccessToken. */
export type TwitterAccessTokenPayload = {
  __typename?: 'TwitterAccessTokenPayload';
  accessToken?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of TwitterRequestToken */
export type TwitterRequestTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of TwitterRequestToken. */
export type TwitterRequestTokenPayload = {
  __typename?: 'TwitterRequestTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  requestToken?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UnapprovePayrollItem */
export type UnapprovePayrollItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  payrollItemId: Scalars['ID'];
};

/** Autogenerated return type of UnapprovePayrollItem. */
export type UnapprovePayrollItemPayload = {
  __typename?: 'UnapprovePayrollItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  payrollItem?: Maybe<PayrollItem>;
};

/** Autogenerated input type of Unmasq */
export type UnmasqInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of Unmasq. */
export type UnmasqPayload = {
  __typename?: 'UnmasqPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of Unsubscribe */
export type UnsubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  emailSubscriptionId?: InputMaybe<Scalars['ID']>;
  /** unsubscribe token to identify the subscription */
  token?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of Unsubscribe. */
export type UnsubscribePayload = {
  __typename?: 'UnsubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  emailSubscription?: Maybe<EmailSubscription>;
  errors?: Maybe<Array<Error>>;
  unsubscribedFromAllEmails?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of UpdateBlogPost */
export type UpdateBlogPostInput = {
  blogCategoryId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  blogCategoryRawId?: InputMaybe<Scalars['Int']>;
  blogPostId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  blogPostRawId?: InputMaybe<Scalars['Int']>;
  blogSubcategoryId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  blogSubcategoryRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title?: InputMaybe<Scalars['String']>;
  /** use null to remove the video attached to the blog post */
  videoId?: InputMaybe<Scalars['ID']>;
  /**
   * use 0 to remove the video attached to the blog post
   * @deprecated only used in legacy frontend code
   */
  videoRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateBlogPost. */
export type UpdateBlogPostPayload = {
  __typename?: 'UpdateBlogPostPayload';
  blogPost?: Maybe<BlogPost>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of UpdateBonus */
export type UpdateBonusInput = {
  autoApprove?: InputMaybe<Scalars['Boolean']>;
  bonusId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Date']>;
  startDate?: InputMaybe<Scalars['Date']>;
  totalToPayClient: MoneyInput;
};

/** Autogenerated return type of UpdateBonus. */
export type UpdateBonusPayload = {
  __typename?: 'UpdateBonusPayload';
  bonus?: Maybe<Bonus>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of UpdateChatThread */
export type UpdateChatThreadInput = {
  avatarUrl?: InputMaybe<Scalars['String']>;
  chatThreadId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  enableMeetingRoom?: InputMaybe<Scalars['Boolean']>;
  title?: InputMaybe<Scalars['String']>;
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of UpdateChatThread. */
export type UpdateChatThreadPayload = {
  __typename?: 'UpdateChatThreadPayload';
  chatThread?: Maybe<ChatThread>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of UpdateContract */
export type UpdateContractInput = {
  allowHireAccess?: InputMaybe<Scalars['Boolean']>;
  allowManageAccess?: InputMaybe<Scalars['Boolean']>;
  bonusClientRate?: InputMaybe<MoneyInput>;
  bonusPeriod?: InputMaybe<ContractBonusPeriod>;
  clientId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRate?: InputMaybe<MoneyInput>;
  contractId: Scalars['ID'];
  currency?: InputMaybe<Scalars['String']>;
  enableTimesheets?: InputMaybe<Scalars['Boolean']>;
  endDate?: InputMaybe<Scalars['Date']>;
  hidden?: InputMaybe<Scalars['Boolean']>;
  inheritorId?: InputMaybe<Scalars['ID']>;
  invoiceRecipientId?: InputMaybe<Scalars['ID']>;
  isFirmAdmin?: InputMaybe<Scalars['Boolean']>;
  paymentMode?: InputMaybe<PaymentModeEnum>;
  paymentsEnabled?: InputMaybe<Scalars['Boolean']>;
  purchaseOrderNumber?: InputMaybe<Scalars['String']>;
  rateMode?: InputMaybe<RateMode>;
  requireApprovalForPayments?: InputMaybe<Scalars['Boolean']>;
  startDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<ContractStatus>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of UpdateContract. */
export type UpdateContractPayload = {
  __typename?: 'UpdateContractPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contract?: Maybe<Contract>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of UpdateContractRate */
export type UpdateContractRateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRate?: InputMaybe<MoneyInput>;
  contractRateId: Scalars['ID'];
  rateMode?: InputMaybe<RateMode>;
  startedAt?: InputMaybe<Scalars['Date']>;
};

/** Autogenerated return type of UpdateContractRate. */
export type UpdateContractRatePayload = {
  __typename?: 'UpdateContractRatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contractRate?: Maybe<ContractRate>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of UpdateContracts */
export type UpdateContractsInput = {
  clientId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** @deprecated only used for legacy frontend code */
  clientRawId?: InputMaybe<Scalars['Int']>;
  contractIds?: InputMaybe<Array<Scalars['ID']>>;
  /** @deprecated only used for legacy frontend code */
  contractRawIds?: InputMaybe<Array<Scalars['Int']>>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<ContractStatus>;
};

/** Autogenerated return type of UpdateContracts. */
export type UpdateContractsPayload = {
  __typename?: 'UpdateContractsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contracts?: Maybe<Array<Contract>>;
  errors?: Maybe<Array<Error>>;
  totalCount?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of UpdateEmailSubscription */
export type UpdateEmailSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  token?: InputMaybe<Scalars['String']>;
  /** true if the user wishes to enable this subscription */
  userEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateEmailSubscription. */
export type UpdateEmailSubscriptionPayload = {
  __typename?: 'UpdateEmailSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  emailSubscription?: Maybe<EmailSubscription>;
  errors?: Maybe<Array<Error>>;
};

/** Autogenerated input type of UpdateFirm */
export type UpdateFirmInput = {
  additionalInvoiceText?: InputMaybe<Scalars['String']>;
  /** @deprecated this field should be updated via updateUser */
  additionalInvoiceTextUser?: InputMaybe<Scalars['String']>;
  allowInvoiceAutoCharge?: InputMaybe<Scalars['Boolean']>;
  backgroundTheme?: InputMaybe<BackgroundThemeEnum>;
  billingPlanId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used for legacy frontend code */
  billingPlanRawId?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  defaultPaymentMethodId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  emailsForInvoices?: InputMaybe<Array<Scalars['String']>>;
  /** omit this to update the current user's firm */
  firmId?: InputMaybe<Scalars['ID']>;
  greenhouseApiKey?: InputMaybe<Scalars['String']>;
  invoiceSalariesInAdvance?: InputMaybe<Scalars['Boolean']>;
  invoiceSchedule?: InputMaybe<Scalars['String']>;
  logoUrl?: InputMaybe<Scalars['String']>;
  managerForNonPayrollFees?: InputMaybe<Scalars['ID']>;
  minSalaryDaysToInvoice?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  nextAutoInvoiceDate?: InputMaybe<Scalars['DateTime']>;
  purchaseOrderNumberForNonPayrollFees?: InputMaybe<Scalars['String']>;
  /** @deprecated this field should be updated via updateUser */
  purchaseOrderNumberUser?: InputMaybe<Scalars['String']>;
  timezoneName?: InputMaybe<Scalars['String']>;
  unifyInvoicesInPreferredCurrency?: InputMaybe<Scalars['Boolean']>;
  website?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateFirm. */
export type UpdateFirmPayload = {
  __typename?: 'UpdateFirmPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  firm?: Maybe<Firm>;
};

/** Autogenerated input type of UpdateJobDetails */
export type UpdateJobDetailsInput = {
  autoRenew?: InputMaybe<Scalars['Boolean']>;
  availabilityType?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  clientRate?: InputMaybe<MoneyInput>;
  clientRateCents?: InputMaybe<Scalars['Int']>;
  country?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  defaultDistance?: InputMaybe<Scalars['Float']>;
  description?: InputMaybe<Scalars['String']>;
  descriptionExperience?: InputMaybe<Scalars['String']>;
  descriptionResponsibilities?: InputMaybe<Scalars['String']>;
  freelancerSubtypes?: InputMaybe<Array<FreelancerSubtypeAttributes>>;
  freelancerType?: InputMaybe<FreelancerTypeAttributes>;
  fullAddress?: InputMaybe<Scalars['String']>;
  jobCountries?: InputMaybe<Array<Scalars['String']>>;
  jobId?: InputMaybe<Scalars['ID']>;
  jobSkills?: InputMaybe<Array<JobSkillAttributes>>;
  locationLatitude?: InputMaybe<Scalars['Float']>;
  locationLongitude?: InputMaybe<Scalars['Float']>;
  locationType?: InputMaybe<Scalars['String']>;
  minClientRate?: InputMaybe<MoneyInput>;
  minClientRateCents?: InputMaybe<Scalars['Int']>;
  numberOfHires?: InputMaybe<Scalars['Int']>;
  positionTypes?: InputMaybe<Array<Scalars['String']>>;
  projectLengthInMonths?: InputMaybe<Scalars['Int']>;
  rateMode?: InputMaybe<Scalars['String']>;
  referralBounty?: InputMaybe<MoneyInput>;
  referralBountyCents?: InputMaybe<Scalars['Int']>;
  region?: InputMaybe<Scalars['String']>;
  requiredExperienceYears?: InputMaybe<Scalars['Int']>;
  /** @deprecated use jobId instead */
  slug?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<JobStatus>;
  timezoneIdentifier?: InputMaybe<Scalars['String']>;
  timezoneRange?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateJobDetails. */
export type UpdateJobDetailsPayload = {
  __typename?: 'UpdateJobDetailsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  job?: Maybe<Job>;
};

/** Autogenerated input type of UpdateJobScreening */
export type UpdateJobScreeningInput = {
  allowTextualAnswers?: InputMaybe<Scalars['Boolean']>;
  autoSendScreeningRequests?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  project?: InputMaybe<ProjectAttributes>;
  questions?: InputMaybe<Array<QuestionAttributes>>;
  requestVideoIntroduction?: InputMaybe<Scalars['Boolean']>;
  screeningRequestMessageTemplate?: InputMaybe<Scalars['String']>;
  slug: Scalars['String'];
};

/** Autogenerated return type of UpdateJobScreening. */
export type UpdateJobScreeningPayload = {
  __typename?: 'UpdateJobScreeningPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  job?: Maybe<Job>;
};

/** Autogenerated input type of UpdateJobSourcing */
export type UpdateJobSourcingInput = {
  activeJobIntegrationsNames?: InputMaybe<Array<Scalars['String']>>;
  automaticallyNotifyCandidates?: InputMaybe<Scalars['Boolean']>;
  candidatesToNotify?: InputMaybe<Array<CandidateToNotifyAttributes>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  hiringManagerId?: InputMaybe<Scalars['Int']>;
  jobSocialIntegrations?: InputMaybe<Array<Scalars['String']>>;
  linkedinCompanyId?: InputMaybe<Scalars['String']>;
  referralBounty?: InputMaybe<MoneyInput>;
  slug: Scalars['String'];
  userId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateJobSourcing. */
export type UpdateJobSourcingPayload = {
  __typename?: 'UpdateJobSourcingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  job?: Maybe<Job>;
};

/** Autogenerated input type of UpdateProjectSubmission */
export type UpdateProjectSubmissionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  projectSubmissionId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used to support some legacy frontend code */
  projectSubmissionRawId?: InputMaybe<Scalars['Int']>;
  screenshotUrl?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<ProjectSubmissionStatusEnum>;
  url?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateProjectSubmission. */
export type UpdateProjectSubmissionPayload = {
  __typename?: 'UpdateProjectSubmissionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  projectSubmission?: Maybe<ProjectSubmission>;
};

/** Autogenerated input type of UpdateSalary */
export type UpdateSalaryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  customAmount?: InputMaybe<Scalars['Boolean']>;
  daysOff?: InputMaybe<Array<Scalars['Date']>>;
  editDescription?: InputMaybe<Scalars['String']>;
  salaryId: Scalars['ID'];
  totalToPayClient?: InputMaybe<MoneyInput>;
};

/** Autogenerated return type of UpdateSalary. */
export type UpdateSalaryPayload = {
  __typename?: 'UpdateSalaryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  salary?: Maybe<Salary>;
};

/** Autogenerated input type of UpdateTimesheet */
export type UpdateTimesheetInput = {
  clientId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Date']>;
  projectCodes?: InputMaybe<Array<Scalars['String']>>;
  startDate?: InputMaybe<Scalars['Date']>;
  submit?: InputMaybe<Scalars['Boolean']>;
  timesheetEntries?: InputMaybe<Array<TimesheetEntryAttributes>>;
  timesheetId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of UpdateTimesheet. */
export type UpdateTimesheetPayload = {
  __typename?: 'UpdateTimesheetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  timesheet?: Maybe<Timesheet>;
};

/** Autogenerated input type of UpdateUnsubscribedFromAllEmails */
export type UpdateUnsubscribedFromAllEmailsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** if the user is logged out, the mutation can be performed using an unsubscribe token */
  token?: InputMaybe<Scalars['String']>;
  unsubscribeFromAllEmails: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateUnsubscribedFromAllEmails. */
export type UpdateUnsubscribedFromAllEmailsPayload = {
  __typename?: 'UpdateUnsubscribedFromAllEmailsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  unsubscribedFromAllEmails?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of UpdateUser */
export type UpdateUserInput = {
  accept?: InputMaybe<Scalars['Boolean']>;
  additionalInvoiceText?: InputMaybe<Scalars['String']>;
  /** used only for the frontend to autosave profile changes */
  autosave?: InputMaybe<Scalars['Boolean']>;
  avatarUrl?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  currentPassword?: InputMaybe<Scalars['String']>;
  defaultPayoutMethodId?: InputMaybe<Scalars['ID']>;
  displayDialogAfterSavingDraftTimesheet?: InputMaybe<Scalars['Boolean']>;
  email?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  freelancerSubtypeRawIds?: InputMaybe<Array<Scalars['Int']>>;
  hidden?: InputMaybe<Scalars['Boolean']>;
  lastName?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  passwordConfirmation?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileAttributes>;
  purchaseOrderNumber?: InputMaybe<Scalars['String']>;
  reject?: InputMaybe<Scalars['Boolean']>;
  sendTimesheetReminders?: InputMaybe<Scalars['Boolean']>;
  skills?: InputMaybe<Array<UserSkillAttributes>>;
  status?: InputMaybe<Scalars['String']>;
  teamInvitationMessage?: InputMaybe<Scalars['String']>;
  timelineEntries?: InputMaybe<Array<TimelineEntryAttributes>>;
  timezoneName?: InputMaybe<Scalars['String']>;
  timezoneOffset?: InputMaybe<Scalars['Float']>;
  unsubscribedFromAllEmails?: InputMaybe<Scalars['Boolean']>;
  /** omit this to update the current user */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of UpdateUser. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpdateVideo */
export type UpdateVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** if false, the video will not be displayed on the public profile */
  public?: InputMaybe<Scalars['Boolean']>;
  videoId?: InputMaybe<Scalars['ID']>;
  /** @deprecated only used in legacy frontend code */
  videoRawId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateVideo. */
export type UpdateVideoPayload = {
  __typename?: 'UpdateVideoPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  video?: Maybe<Video>;
};

/** Autogenerated input type of UpdateWebhook */
export type UpdateWebhookInput = {
  /** if both this and authenticationHeaderValue are present, the header will be sent for all webhooks */
  authenticationHeaderName?: InputMaybe<Scalars['String']>;
  /** this value is write-only. It can only be read in this mutation's result, if the mutation is changing it */
  authenticationHeaderValue?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** if false, events will not be sent to this Webhook */
  enabled?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  /**
   * HTTP POST requests with JSON bodies will be sent to this URL. The fields on
   * the body are 'event_name', 'timestamp' (unix integer format) and 'records'
   * (array of string IDs of related records)
   */
  url?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateWebhook. */
export type UpdateWebhookPayload = {
  __typename?: 'UpdateWebhookPayload';
  /** use this field if you need to validate that the authentication header value was set correctly */
  authenticationHeaderValue?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** the webhook just edited */
  webhook?: Maybe<Webhook>;
};

export type User = Node & {
  __typename?: 'User';
  /** extra text that will be added on invoices to this user */
  additionalInvoiceText?: Maybe<Scalars['String']>;
  allApplications?: Maybe<ApplicationsResults>;
  allBonuses?: Maybe<BonusConnection>;
  allCandidates?: Maybe<CandidateConnection>;
  /** all chat messages from all threads that the user is in */
  allChatMessages?: Maybe<ChatMessageConnection>;
  allContractStats?: Maybe<ContractStats>;
  /**
   * will behave like firm.contracts for client accounts, and behave like the normal contracts field otherwise
   * @deprecated only used in legacy frontend code
   */
  allContracts?: Maybe<ContractConnection>;
  allExpenses?: Maybe<ExpenseConnection>;
  allInvoices?: Maybe<InvoiceConnection>;
  allInvoicesSummary?: Maybe<InvoicesSummary>;
  allJobs?: Maybe<JobConnection>;
  allPaymentMethods?: Maybe<Array<PaymentMethod>>;
  allPayrollItems?: Maybe<PayrollItemConnection>;
  allSalaries?: Maybe<SalaryConnection>;
  allScreening?: Maybe<ApplicationsResults>;
  allTimesheets?: Maybe<TimesheetConnection>;
  /** video answers submitted by this user */
  answers?: Maybe<Array<Video>>;
  /** will be true if this user can manage and use API keys */
  apiAccess?: Maybe<Scalars['Boolean']>;
  apiKeys?: Maybe<Array<ApiKey>>;
  applications?: Maybe<ApplicationsResults>;
  appliedAt?: Maybe<Scalars['DateTime']>;
  avatarUrl?: Maybe<Scalars['String']>;
  backgroundCheck?: Maybe<BackgroundCheck>;
  /** @deprecated read the backgroundCheck field instead */
  backgroundCheckCompleted?: Maybe<Scalars['Boolean']>;
  blockPlatformAccessDueToUnpaidInvoices?: Maybe<Scalars['Boolean']>;
  blockPlatformAccessDueToUnpaidInvoicesDate?: Maybe<Scalars['Date']>;
  blogPosts?: Maybe<BlogPostConnection>;
  bonusesStats?: Maybe<PayrollStats>;
  calendlyUrl?: Maybe<Scalars['String']>;
  canMakeOffer?: Maybe<Scalars['Boolean']>;
  canNotify?: Maybe<Scalars['Boolean']>;
  canRequestInterview?: Maybe<Scalars['Boolean']>;
  canSetupPayoutMethod?: Maybe<Scalars['Boolean']>;
  candidates?: Maybe<CandidateConnection>;
  /** @deprecated use user.contacts instead */
  chatContacts?: Maybe<UserConnection>;
  /** all chat messages written by this user */
  chatMessages?: Maybe<ChatMessageConnection>;
  chatThreads?: Maybe<ChatThreadConnection>;
  clientBonuses?: Maybe<BonusConnection>;
  /** all the contracts in which this user is involved as client */
  clientContracts?: Maybe<ContractConnection>;
  clientExpenses?: Maybe<ExpenseConnection>;
  clientPayrollItems?: Maybe<PayrollItemConnection>;
  clientSalaries?: Maybe<SalaryConnection>;
  clientTimesheets?: Maybe<TimesheetConnection>;
  colleagues?: Maybe<Array<User>>;
  /** frontend configuration values for this user */
  configuration?: Maybe<Configuration>;
  confirmedEmail?: Maybe<Scalars['Boolean']>;
  contacts?: Maybe<UserConnection>;
  contractSigned?: Maybe<Scalars['Boolean']>;
  contractStats?: Maybe<ContractStats>;
  contractorAgreementTemplateUrl?: Maybe<Scalars['String']>;
  contractorStatementOfWorkTemplateUrl?: Maybe<Scalars['String']>;
  /** all the contracts in which this user is involved as client/manager or individual */
  contracts?: Maybe<ContractConnection>;
  costBreakdown?: Maybe<PayrollBreakdown>;
  createdAt?: Maybe<Scalars['DateTime']>;
  directChatThread?: Maybe<ChatThread>;
  displayDialogAfterSavingDraftTimesheet?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  emailSubscriptions?: Maybe<Array<EmailSubscription>>;
  expenses?: Maybe<ExpenseConnection>;
  expensesStats?: Maybe<PayrollStats>;
  /**
   * true if this member has completed the feature step on their profile
   * @deprecated use the backgroundCheck field instead
   */
  featureStepCompleted: Scalars['Boolean'];
  /** true if this member is featured on the Flexhire homepage */
  featured?: Maybe<Scalars['Boolean']>;
  /** for clients only. Associated companies this user has some level of manage access in */
  firms?: Maybe<Array<Firm>>;
  firstName?: Maybe<Scalars['String']>;
  freelancerBonuses?: Maybe<BonusConnection>;
  /** all the contracts in which this user is involved as invidivual */
  freelancerContracts?: Maybe<ContractConnection>;
  freelancerPayrollItems?: Maybe<PayrollItemConnection>;
  freelancerSalaries?: Maybe<SalaryConnection>;
  freelancerTimesheets?: Maybe<TimesheetConnection>;
  fullAddress?: Maybe<Scalars['String']>;
  /** if true, the user has an account but hasn't completed signup so should be treated as a user without an account */
  guest: Scalars['Boolean'];
  hasActivePayoutMethod?: Maybe<Scalars['Boolean']>;
  /** true if this user has been invited to the platform with an offer */
  hasInvitationContracts?: Maybe<Scalars['Boolean']>;
  hasInvoiceAccess?: Maybe<Scalars['Boolean']>;
  /** true if this client has any hired or invited members */
  hasTeam?: Maybe<Scalars['Boolean']>;
  hidden?: Maybe<Scalars['Boolean']>;
  /** @deprecated use firm.billingPlan values */
  hireSourcedByClientMargin?: Maybe<Scalars['Float']>;
  /** @deprecated use firm.billingPlan values */
  hireSourcedByFlexhireMargin?: Maybe<Scalars['Float']>;
  id: Scalars['ID'];
  incomeBreakdown?: Maybe<PayrollBreakdown>;
  /** name of the integration this user has been imported from, if any */
  integrationName?: Maybe<Scalars['String']>;
  /** @deprecated use firm.billingPlan values */
  inviteMargin?: Maybe<Scalars['Float']>;
  /** true if this user has been invited to apply to the given job */
  invitedToJob?: Maybe<Scalars['Boolean']>;
  invoices?: Maybe<InvoiceConnection>;
  /** true if this user is in the chat contacts of the current user */
  isChatContact?: Maybe<Scalars['Boolean']>;
  /**
   * if true, the user is a client on the platform, which means they are part of at
   * least one firm with some level of management permissions
   */
  isClient: Scalars['Boolean'];
  /** true if this user is a customer success rep for the current user's firm */
  isCustomerSuccessRep?: Maybe<Scalars['Boolean']>;
  isFlexhireTeam?: Maybe<Scalars['Boolean']>;
  /** if true, the user is a member/individual on the platform and has a profile */
  isMember: Scalars['Boolean'];
  isProfileFeedback?: Maybe<Scalars['Boolean']>;
  /** true if this user is a recruiter for the current user's firm */
  isRecruiter?: Maybe<Scalars['Boolean']>;
  jobApplicationsCount?: Maybe<Scalars['Int']>;
  /** used in hire pipeline for candidates and potential applicants: contains any reasons for blocking application to job */
  jobIncompatibilityReasons?: Maybe<Array<Scalars['String']>>;
  jobOpportunities?: Maybe<JobConnection>;
  jobs?: Maybe<JobConnection>;
  lastName?: Maybe<Scalars['String']>;
  lastSeenAt?: Maybe<Scalars['DateTime']>;
  /** @deprecated use country, fullAddress, city, region instead */
  location?: Maybe<Scalars['String']>;
  /**
   * contract with this user's superior in the company. Only for clients
   * @deprecated search contracts with firm filter instead
   */
  managerContract?: Maybe<Contract>;
  /** saved message to send when inviting managers */
  managerInvitationMessage?: Maybe<Scalars['String']>;
  /** @deprecated use country, fullAddress, city, region instead */
  minMarginUsd?: Maybe<Scalars['Float']>;
  /** combination of firstName and lastName */
  name?: Maybe<Scalars['String']>;
  passwordSetupRequired?: Maybe<Scalars['Boolean']>;
  paychecks?: Maybe<PaycheckConnection>;
  paymentMethods?: Maybe<Array<PaymentMethod>>;
  /** default payout method */
  payoutMethod?: Maybe<PayoutMethod>;
  payoutMethods?: Maybe<Array<PayoutMethod>>;
  payouts?: Maybe<PayoutConnection>;
  payoutsStats?: Maybe<PayoutsStats>;
  phone?: Maybe<Scalars['String']>;
  /** for members only. Associated profile data */
  profile?: Maybe<Profile>;
  projectSubmissions?: Maybe<Array<ProjectSubmission>>;
  /** will be added to all invoices to this user */
  purchaseOrderNumber?: Maybe<Scalars['String']>;
  ratingCountHigh?: Maybe<Scalars['Int']>;
  ratingCountLow?: Maybe<Scalars['Int']>;
  ratingCountMedium?: Maybe<Scalars['Int']>;
  rawId?: Maybe<Scalars['Int']>;
  /** will reference the 'real user' when using the masking feature to mask into another account */
  realUser?: Maybe<User>;
  /** raw IDs of users whose invoices are being managed by this user */
  receivesInvoicesFor?: Maybe<Array<Scalars['Int']>>;
  references?: Maybe<Array<Reference>>;
  /**
   * the contract between your company and this user. Only for clients
   * @deprecated search contracts with firm filter instead
   */
  relatedContract?: Maybe<Contract>;
  remoteDebugCode?: Maybe<Scalars['String']>;
  requestedBackgroundChecks?: Maybe<BackgroundCheckConnection>;
  resume?: Maybe<Resume>;
  /** list of roles the user has. These will affect API permissions and visibility and the frontend UI */
  roles: Array<UserRoleEnum>;
  salariesStats?: Maybe<PayrollStats>;
  screening?: Maybe<ApplicationsResults>;
  /** will be true if this is the same user that is querying the API */
  self?: Maybe<Scalars['Boolean']>;
  sendTimesheetReminders?: Maybe<Scalars['Boolean']>;
  /** true if it's a skipped candidate */
  skipped?: Maybe<Scalars['Boolean']>;
  /** only relevant for members */
  status?: Maybe<UserStatus>;
  /** recommended questions to answer to boost candidate score for a member */
  suggestedQuestions?: Maybe<Array<Question>>;
  /** saved message to send when inviting members */
  teamInvitationMessage?: Maybe<Scalars['String']>;
  termsOfServiceApproved?: Maybe<Scalars['Boolean']>;
  timelineEntries?: Maybe<Array<TimelineEntry>>;
  /** @deprecated use freelancerTimesheets instead */
  timesheets?: Maybe<TimesheetConnection>;
  timesheetsStats?: Maybe<PayrollStats>;
  timezone?: Maybe<Scalars['String']>;
  timezoneName?: Maybe<Scalars['String']>;
  timezoneOffset?: Maybe<Scalars['Int']>;
  /** contains the new email address when changing address and not having the new one confirmed yet */
  unconfirmedEmail?: Maybe<Scalars['String']>;
  unsubscribedFromAllEmails?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userSkills?: Maybe<Array<UserSkill>>;
  /** true if this member is pre-screened */
  verified?: Maybe<Scalars['Boolean']>;
  /** video introduction */
  video?: Maybe<Video>;
  webhooks?: Maybe<Array<Webhook>>;
  workingOrOfferedJob?: Maybe<Scalars['Boolean']>;
};


export type UserAllApplicationsArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


export type UserAllBonusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<BonusesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllCandidatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<CandidatesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllChatMessagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ChatMessageFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllContractStatsArgs = {
  filters?: InputMaybe<ContractsFilters>;
};


export type UserAllContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllExpensesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ExpensesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<InvoicesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllInvoicesSummaryArgs = {
  filters?: InputMaybe<InvoicesFilters>;
};


export type UserAllJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<JobsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllPaymentMethodsArgs = {
  cardsOnly?: InputMaybe<Scalars['Boolean']>;
  exceptCards?: InputMaybe<Scalars['Boolean']>;
};


export type UserAllPayrollItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PayrollItemsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllSalariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<SalariesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAllScreeningArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


export type UserAllTimesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<TimesheetsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserAnswersArgs = {
  jobId?: InputMaybe<Scalars['Int']>;
};


export type UserApplicationsArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


export type UserBlogPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserBonusesStatsArgs = {
  filters?: InputMaybe<BonusesFilters>;
};


export type UserCandidatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<CandidatesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserChatContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type UserChatMessagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ChatMessageFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserChatThreadsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type UserClientBonusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<BonusesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserClientContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserClientExpensesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ExpensesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserClientPayrollItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PayrollItemsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserClientSalariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<SalariesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserClientTimesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<TimesheetsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  refresh?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
};


export type UserContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserCostBreakdownArgs = {
  freelancerId?: InputMaybe<Scalars['ID']>;
  groupBy: PayrollBreakdownGroupByEnum;
};


export type UserExpensesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ExpensesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserExpensesStatsArgs = {
  filters?: InputMaybe<ExpensesFilters>;
};


export type UserFreelancerBonusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<BonusesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserFreelancerContractsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ContractsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserFreelancerPayrollItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PayrollItemsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserFreelancerSalariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<SalariesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserFreelancerTimesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<TimesheetsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserIncomeBreakdownArgs = {
  groupBy: PayrollBreakdownGroupByEnum;
};


export type UserInvitedToJobArgs = {
  jobId?: InputMaybe<Scalars['Int']>;
  jobSlug?: InputMaybe<Scalars['String']>;
};


export type UserInvoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<InvoicesFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserJobIncompatibilityReasonsArgs = {
  jobId?: InputMaybe<Scalars['Int']>;
  jobSlug?: InputMaybe<Scalars['String']>;
};


export type UserJobOpportunitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<JobsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<JobsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserPaychecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PaychecksFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserPaymentMethodsArgs = {
  cardsOnly?: InputMaybe<Scalars['Boolean']>;
  exceptCards?: InputMaybe<Scalars['Boolean']>;
};


export type UserPayoutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<PayoutsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserPayoutsStatsArgs = {
  filters?: InputMaybe<PayoutsFilters>;
};


export type UserRequestedBackgroundChecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserSalariesStatsArgs = {
  filters?: InputMaybe<SalariesFilters>;
};


export type UserScreeningArgs = {
  filters?: InputMaybe<CandidatesFilters>;
};


export type UserTimesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<TimesheetsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserTimesheetsStatsArgs = {
  filters?: InputMaybe<TimesheetsFilters>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

export enum UserRoleEnum {
  /** Flexhire admin, has the highest level of permissions possible */
  Admin = 'admin',
  /** Not in use at the moment */
  CustomerSuccessRep = 'customer_success_rep',
  /** Can be assigned to customers and manage their hiring pipeline */
  Recruiter = 'recruiter',
  /** Flexhire sales account. Can manage firms */
  Sales = 'sales',
  /** Flexhire screening account. Can review member applications for pre-screening */
  Screening = 'screening'
}

export type UserSkill = Node & {
  __typename?: 'UserSkill';
  experience?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  skill?: Maybe<Skill>;
};

export type UserSkillAttributes = {
  experience?: InputMaybe<Scalars['Int']>;
  rawSkillId: Scalars['Int'];
};

export enum UserStatus {
  Accepted = 'accepted',
  Applied = 'applied',
  Applying = 'applying',
  Deleted = 'deleted',
  Interview = 'interview',
  Pending = 'pending',
  Rejected = 'rejected',
  Unverified = 'unverified'
}

/** Autogenerated return type of UserUpdated. */
export type UserUpdatedPayload = {
  __typename?: 'UserUpdatedPayload';
  user?: Maybe<User>;
};

export type ValidationResult = {
  __typename?: 'ValidationResult';
  error?: Maybe<Scalars['String']>;
  valid: Scalars['Boolean'];
};

export type Video = Node & {
  __typename?: 'Video';
  available: Scalars['Boolean'];
  contractRequests?: Maybe<Array<ContractRequest>>;
  createdAt: Scalars['DateTime'];
  /** for company videos */
  firm?: Maybe<Firm>;
  id: Scalars['ID'];
  /** video url served by CDN */
  optimizedUrl: Scalars['String'];
  /** preview image for the video */
  posterUrl?: Maybe<Scalars['String']>;
  public: Scalars['Boolean'];
  /** for video answers */
  question?: Maybe<Question>;
  rawId?: Maybe<Scalars['Int']>;
  status: VideoStatusEnum;
  /** the raw file url of the video file */
  url: Scalars['String'];
  /** video owner */
  user?: Maybe<User>;
  videoType: VideoTypeEnum;
};

export enum VideoStatusEnum {
  Pending = 'pending',
  Processed = 'processed',
  Processing = 'processing',
  ProcessingFailed = 'processing_failed',
  ProcessingQueued = 'processing_queued',
  Unprocessed = 'unprocessed'
}

export enum VideoTypeEnum {
  Answer = 'answer',
  BlogPost = 'blog_post',
  Company = 'company',
  Profile = 'profile'
}

/** Autogenerated return type of VideoUpdated. */
export type VideoUpdatedPayload = {
  __typename?: 'VideoUpdatedPayload';
  video?: Maybe<Video>;
};

/** webhooks used by Flexhire to send events to external services */
export type Webhook = Node & {
  __typename?: 'Webhook';
  /**
   * if both this and authenticationHeaderValue are present, the header will be
   * sent for all webhooks. The value is not write-only for security reasons.
   */
  authenticationHeaderName?: Maybe<Scalars['String']>;
  /** this field will always return null for security reasons */
  authenticationHeaderValue?: Maybe<Scalars['String']>;
  /** if false, events won't be sent */
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  url: Scalars['String'];
  webhookDeliveries?: Maybe<WebhookDeliveryConnection>;
};


/** webhooks used by Flexhire to send events to external services */
export type WebhookWebhookDeliveriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WebhookDelivery = Node & {
  __typename?: 'WebhookDelivery';
  createdAt: Scalars['DateTime'];
  eventName: Scalars['String'];
  id: Scalars['ID'];
  status: Scalars['String'];
  webhook?: Maybe<Webhook>;
};

/** The connection type for WebhookDelivery. */
export type WebhookDeliveryConnection = {
  __typename?: 'WebhookDeliveryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WebhookDeliveryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WebhookDelivery>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type WebhookDeliveryEdge = {
  __typename?: 'WebhookDeliveryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<WebhookDelivery>;
};
